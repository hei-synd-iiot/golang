{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go Programming Language Hands-On","text":""},{"location":"#introduction","title":"Introduction","text":"<p>In this hands-on you will learn the basic concepts and syntax of the Go programming language.</p> <ul> <li>You are able to develop simple applications using the Go programming language.</li> <li>You can compile and run Go programs on your local machine and on a Raspberry Pi remotely.</li> <li>You have chosen an IDE for developing Go applications for yourself and know how to use it.</li> </ul> <p>Note that this course is not a complete and comprehensive guide to the Go programming language. It is designed to provide you with a basic understanding of Go and help you get started with Go for this course. If you want to learn more about Go, you can refer to the official Go documentation and other online resources. This guide is non theless not  for beginners, but for people who already have some decent programming experience. </p> <p>The hands-on should be completed in 4 hours</p> <p>The time to spend on this hands-on should not exceed 4 hours. If you can not finish it in this time, you should continue to work on it at home.</p> Read tips, they are really useful! <p>Through this hands-on, we provide useful tips that might help you during the project. These tips are always provided in boxes like this one.</p> Always read the information in these boxes and keep it in mind. <p>Indispensable information that you will need to keep in mind as you will use that often during the project is always provided in red boxes like this one.</p> Complete all tasks in this hands-on <p>The basic idea of these hands-on are learning by doing, so there are tasks in these hands-on documents that you should complete. These tasks are always provided in boxes like this one.</p> If you have any questions, need help or found an error, don't hesitate to contact me. <p>I will be happy to help you. Just write an email to michael.clausen@hevs.ch with your feedback.</p>"},{"location":"#why-another-programming-language","title":"Why another programming language?","text":"<p>The motivation to use Go extends beyond its simplicity, efficiency, and scalability, encompassing robust security features that are crucial in today's software  landscape, especially for devices exposed to the internet. Developed with a focus on secure coding practices, Go offers several key security advantages that make it an  attractive choice for building secure and resilient applications.</p> <p></p> <p>First and foremost, Go's statically typed nature and strict compiler checks help catch common programming errors at compile time, reducing the likelihood of vulnerabilities  such as buffer overflows, null pointer dereferences, and type mismatches. This proactive approach to error detection enhances the overall security posture of Go  applications, making them less susceptible to exploitation. </p> <p>Moreover, Go's memory safety features, including automatic garbage collection and bounds checking, mitigate the risk of memory-related vulnerabilities such as buffer  overflows and memory leaks. By managing memory allocation and deallocation automatically, Go minimizes the potential for memory corruption vulnerabilities that are commonly  exploited by attackers.</p> <p>Additionally, Go's standard library and ecosystem prioritize secure coding practices and provide built-in support for common security mechanisms such as encryption,  authentication, and access control. Whether handling sensitive data or implementing secure communication protocols, developers can leverage Go's robust standard library to  implement security features without relying on third-party dependencies or external libraries with potential security vulnerabilities.</p> <p>Furthermore, Go's concurrency model, based on lightweight goroutines and channels, facilitates the development of secure and scalable concurrent applications. By offering  a simple yet powerful concurrency mechanism, Go enables developers to write thread-safe and race-condition-free code, reducing the risk of security vulnerabilities  associated with concurrent programming.</p> <p>In the case of this course, the Go programming language will help us to implement robust, efficient, secure distributed applications.</p>"},{"location":"#history-of-the-go-programming-language","title":"History of the Go programming language","text":"<p>The history of Go, the programming language developed by Google, dates back to 2007 when Robert Griesemer, Rob Pike, and Ken Thompson set out to create a language that  addressed the challenges they faced with existing languages while maintaining their efficiency and simplicity.</p> <p></p> <p>In 2009, Google officially announced the existence of Go, releasing it as an open-source project. The language was designed to cater to the growing need for efficient and scalable programming tools, particularly in the context of large-scale distributed systems and concurrent programming.</p> <p>Over the years, Go has undergone significant development and refinement, with regular updates and contributions from a thriving community of developers worldwide. Today, Go  continues to evolve as a modern programming language, with Google and the Go community actively working to enhance its features, improve its performance, and expand its  ecosystem of libraries and tools. With its rich history and ongoing development, Go remains a popular choice for developers seeking a robust and efficient platform for building  reliable and scalable software solutions.</p>"},{"location":"#features-of-the-go-programming-language","title":"Features of the Go programming language","text":"<p>Here's an overview of the key features of Go:</p> <p></p> <ul> <li>Simplicity: Go's syntax is designed to be clean and minimalistic, making it easy to read, write, and maintain code. It reduces unnecessary complexity, allowing developers to    focus on solving problems rather than wrestling with the language itself.</li> </ul> <p></p> <ul> <li>Efficiency: Go offers fast compilation times and efficient runtime performance, making it ideal for building high-performance applications. Its built-in garbage collector   manages memory allocation and deallocation automatically, optimizing resource usage and minimizing overhead.</li> </ul> <p></p> <ul> <li>Concurrency: Go provides built-in support for concurrency through lightweight goroutines and channels. Goroutines allow developers to execute concurrent tasks efficiently,    while channels facilitate communication and synchronization between goroutines. This concurrency model simplifies the development of scalable and concurrent applications.</li> </ul> <p></p> <ul> <li>Standard Library: Go comes with a comprehensive standard library that includes packages for common tasks such as I/O operations, networking, encryption, and more. The    standard library is well-designed and efficient, providing developers with powerful tools to build robust applications without relying on third-party dependencies.</li> </ul> <p></p> <ul> <li>Static Typing: Go is statically typed, meaning variable types are known at compile time. This helps catch type-related errors early in the development process, improving    code reliability and maintainability.</li> </ul> <p> </p> <ul> <li>Garbage Collection: Go features automatic garbage collection, which manages memory allocation and deallocation, preventing memory leaks and buffer overflows. This simplifies    memory management and reduces the risk of memory-related vulnerabilities.</li> </ul> <p></p> <ul> <li>Cross-Platform Compatibility: Go code can be compiled to run on multiple platforms, including Linux, macOS, Windows, and more. This cross-platform compatibility enables    developers to write code once and deploy it anywhere, without worrying about platform-specific nuances.</li> </ul> <p></p> <ul> <li>Built-in Testing Support: Go includes a built-in testing framework that makes it easy to write and execute tests for your code. Testing is an integral part of the Go    development workflow, promoting code quality and reliability.</li> </ul> <p></p> <ul> <li>Tooling: Go comes with a set of powerful development tools, including the go command-line tool, the gofmt code formatter, and the go vet static analyzer. These tools    streamline the development process and enforce best practices, ensuring consistency and quality across projects.</li> </ul> <p></p> <ul> <li>Open-Source Community: Go has a vibrant open-source community that contributes to its development and ecosystem. There are numerous third-party packages and libraries    available for Go, covering a wide range of use cases and domains.</li> </ul> <p>Overall, Go's combination of simplicity, efficiency,  concurrency support, and robust tooling makes it an excellent choice for building modern, scalable, and reliable distributed software solutions.</p>"},{"location":"#setting-up-development-environment","title":"Setting up development environment","text":"<p>Setting up a development environment for Go on Windows, macOS, and Linux is relatively straightforward. Below is a step-by-step guide for each operating system:</p> WindowsmacOSLinux (Ubuntu/Debian) <ol> <li> <p>Download Go Installer:</p> <ul> <li>Visit the official Go website (https://golang.org/dl/) and download the latest stable release for Windows.</li> <li>Run the installer executable (.msi file) and follow the installation instructions.</li> </ul> </li> <li> <p>Set Environment Variables:</p> <ul> <li>Open the Control Panel and go to System and Security &gt; System &gt; Advanced system settings.</li> <li>Click on the \"Environment Variables\" button.</li> <li>Under \"System variables\", find the \"Path\" variable and click \"Edit\".</li> <li>Add the path to the Go binary directory (usually <code>C:\\Go\\bin</code>) to the list of paths.</li> <li>Click \"OK\" to save the changes.</li> </ul> </li> <li> <p>Verify Installation:</p> <ul> <li>Open a new command prompt and type <code>go version</code>. You should see the installed Go version printed.</li> </ul> </li> </ol> <ol> <li> <p>Install Homebrew (optional but recommended):</p> <ul> <li>Open Terminal.</li> <li>Install Homebrew by running the following command:   <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></li> </ul> </li> <li> <p>Install Go:</p> <ul> <li>Open Terminal.</li> <li>Run the following command to install Go using Homebrew:   <pre><code>brew install go\n</code></pre></li> </ul> </li> <li> <p>Verify Installation:</p> <ul> <li>Open Terminal and type <code>go version</code>. You should see the installed Go version printed.</li> </ul> </li> </ol> <ol> <li> <p>Update package index:</p> <ul> <li>Open Terminal.</li> <li>Update the package index by running: <pre><code>sudo apt update\n</code></pre></li> </ul> </li> <li> <p>Install Go:</p> <ul> <li>Install Go by running:   <pre><code>sudo apt install golang\n</code></pre></li> </ul> </li> <li> <p>Verify Installation:</p> <ul> <li>Open Terminal and type <code>go version</code>. You should see the installed Go version printed.</li> </ul> </li> </ol> Install Go and test your setup <p>Install Go on your computer and ensure that the simple \"Hello World\" program runs successfully. If you encounter any issues during the installation or setup process, don't hesitate to ask for help. We take it as given after this task that you have successfully installed Go on your computer and are ready to start development anytime.</p> <ul> <li>Install Go on your computer as mentioned above.</li> <li>Create a new directory and navigate to it.</li> <li> <p>Create a new file named <code>hello.go</code> and add the following code: hello.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello world\")\n}\n</code></pre></p> </li> <li> <p>Now run the program using the following command: <pre><code>go run hello.go\n</code></pre></p> </li> </ul>"},{"location":"#ides-and-editors","title":"IDEs and Editors","text":"<p>While Go can be developed using any text editor, there are several IDEs and editors that provide enhanced support for Go development. Some popular options include:</p> Jetbrains GoLand <p></p> <p>GoLand is a full-featured IDE specifically designed for Go development, offering advanced features and tools for writing, testing, and debugging Go code. You can download GoLand  from the JetBrains website https://www.jetbrains.com/go/. GoLand is not free software, but it is free for students and open-source projects.</p> Visual Studio Code <p></p> <p>Visual Studio Code is a lightweight and versatile code editor with excellent Go support through extensions like Go for Visual Studio Code. You can download Visual Studio Code from  the official website https://code.visualstudio.com/. You need to install the Go extension for Visual Studio Code to get Go support.</p> Choose and install an IDE <p>Choose an IDE or editor for Go development based on your personal preferences. Install the necessary extensions or plugins to enable Go support in your chosen IDE. If you need help setting up your IDE, feel free to ask for assistance.</p> <ul> <li>Choose an IDE or editor for Go development.</li> <li>Install the IDE aling with the necessary extensions or plugins for Go support.</li> <li>Familiarize yourself with the basic features and tools available in your chosen IDE.</li> </ul>"},{"location":"#basic-syntax","title":"Basic Syntax","text":""},{"location":"#hello-world","title":"Hello World","text":"<p>Our first program will print the classic \u201chello world\u201d message. Here is the full source code.</p> <p></p> <pre><code>package main // (1)!\n\nimport \"fmt\" // (2)!\n\nfunc main() { // (3)!\n    fmt.Println(\"hello world\") // (4)!\n}\n</code></pre> <ol> <li>Every Go file starts with a <code>package</code> declaration. In this case, we use the <code>main</code> package, which is the entry point for the executable program.</li> <li>We import the <code>fmt</code> package, which contains functions for formatting text and printing output. The <code>fmt.Println</code> function is used to print messages to the console.</li> <li>The <code>main</code> function is the entry point for the program. When the program is executed, the code inside the <code>main</code> function is executed sequentially.</li> <li>The <code>fmt.Println</code> function is used to print the message \"hello world\" to the console.</li> </ol> <p>To run the program, put the code in <code>hello-world.go</code> and use <code>go run</code>.</p> <pre><code>$ go run hello-world.go\n</code></pre> Go programs can be run using the <code>go run</code> command. <p>To run a Go program, you can use the <code>go run</code> command followed by the name of the Go file. This command compiles and runs the program in a single step, making it easy to test  and execute Go code. Using an IDE with built-in support for Go development can also simplify the process of running Go programs.</p> <p>Sometimes we want to build our programs into binaries. We can do this using <code>go build</code>.</p> <pre><code>$ go build hello-world.go\n</code></pre> <p>We can then execute the built binary directly.</p> <pre><code>$ ./hello-world\n</code></pre> Go programs can be compiled into binaries using the <code>go build</code> command. <p>The <code>go build</code> command compiles a Go program into an executable binary file. This binary can be run directly on the target platform without the need for the Go runtime. The  resulting binary file will have the same name as the Go source file without the <code>.go</code> extension.</p>"},{"location":"#values","title":"Values","text":"<p>Go has various value types including strings, integers, floats, booleans, etc. Here are a few basic examples.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    fmt.Println(\"go\" + \"lang\")  // (1)!\n\n    fmt.Println(\"2+2 =\", 2+2) // (2)!\n    fmt.Println(\"7.0/3.0 =\", 7.0/3.0) // (3)!\n\n    fmt.Println(true &amp;&amp; false) // (4)!\n    fmt.Println(true || false)\n    fmt.Println(!true)\n}\n</code></pre> <ol> <li>Strings, which can be added together with +.</li> <li>Integers.</li> <li>Floats.</li> <li>Booleans, with boolean operators as you\u2019d expect.</li> </ol>"},{"location":"#variables","title":"Variables","text":"<p>In Go, variables are explicitly declared and used by the compiler to e.g. check type-correctness of function calls.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var a = \"initial\" // (1)!\n    fmt.Println(a)\n\n    var b, c int = 1, 2 // (2)!\n    fmt.Println(b, c)\n\n    var d = true // (3)!\n    fmt.Println(d)\n\n    var e int // (4)!\n    fmt.Println(e)\n\n    f := \"apple\" // (5)!\n    fmt.Println(f)\n}\n</code></pre> <ol> <li><code>var</code> declares 1 or more variables.</li> <li>You can declare multiple variables at once.</li> <li>Go will infer the type of initialized variables.</li> <li>Variables declared without a corresponding initialization are zero-valued. For example, the zero value for an int is 0.</li> <li>The <code>:=</code> syntax is shorthand for declaring and initializing a variable, e.g. for <code>var f string = \"apple\"</code> in this case. This syntax is only available inside functions.</li> </ol> Go is a statically typed language. <p>Go is a statically typed language, which means that variable types are known at compile time. This allows the compiler to catch type-related errors early in the development  process, improving code reliability and maintainability.</p> Go uses type inference. <p>Go supports type inference, which allows the compiler to infer the type of a variable based on its initialization value. This reduces the need for explicit type declarations and  makes the code more concise and readable.</p> Go variables are zero-valued by default. <p>In Go, variables declared without an explicit initialization value are zero-valued. The zero value of a variable depends on its type, such as 0 for integers, false for  booleans, and \"\" for strings.</p> Go supports short variable declarations. <p>Go provides a shorthand syntax for declaring and initializing variables using the <code>:=</code> operator. This syntax is commonly used to declare and initialize variables within functions  without explicitly specifying the type.</p>"},{"location":"#constants","title":"Constants","text":"<p>Go supports constants of character, string, boolean, and numeric values.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nconst s string = \"constant\" // (1)!\n\nconst ( // (2)!\n    c1 = 7\n    c2 = 42\n)\n\nfunc main() {\n    fmt.Println(s)\n\n    const n = 500000000 // (3)!\n\n    const d = 3e20 / n // (4)!\n    fmt.Println(d)\n\n    fmt.Println(int64(d)) // (5)!\n\n    fmt.Println(math.Sin(n)) // (6)!\n}\n</code></pre> <ol> <li><code>const</code> declares a constant value.</li> <li><code>const</code> declaration can be grouped.</li> <li>A <code>const</code> statement can appear anywhere a <code>var</code> statement can.</li> <li>Constant expressions perform arithmetic with arbitrary precision.</li> <li>A numeric constant has no type until it\u2019s given one, such as by an explicit conversion.</li> <li>number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64.</li> </ol> Go constants are immutable. <p>Go constants are immutable values that cannot be changed or reassigned once they are declared. This immutability ensures that constants retain their values throughout the  program's execution, making them suitable for defining fixed values that should not be modified.</p> Go constants do not have a type until they are given one. <p>Unlike variables, Go constants do not have an explicit type until they are used in a context that requires one. This allows constants to be used in a flexible manner without  being tied to a specific type until necessary.</p>"},{"location":"#for","title":"For","text":"<p><code>for</code> is Go\u2019s only looping construct. Here are some basic types of for loops.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    i := 1 // (1)!\n    for i &lt;= 3 {\n        fmt.Println(i)\n        i = i + 1\n    }\n\n    for j := 0; j &lt; 3; j++ { //(2)!\n        fmt.Println(j)\n    }\n\n    for i := range 3 { // (3)!\n        fmt.Println(\"range\", i)\n    }\n\n    for { // (4)!\n        fmt.Println(\"loop\")\n        break\n    }\n\n    for n := range 6 { //(5)!\n        if n%2 == 0 {\n            continue\n        }\n        fmt.Println(n)\n    }\n}\n</code></pre> <ol> <li>The most basic type, with a single condition.</li> <li>A classic initial/condition/after for loop.</li> <li>Another way of accomplishing the basic \u201cdo this N times\u201d iteration is range over an integer.</li> <li><code>for</code> without a condition will loop repeatedly until you <code>break</code> out of the loop or <code>return</code> from the enclosing function.</li> <li>You can also <code>continue</code> to the next iteration of the loop.</li> </ol> <p>We\u2019ll see some other for forms later when we look at range statements, channels, and other data structures.</p>"},{"location":"#ifelse","title":"If/Else","text":"<p>Branching with <code>if</code> and <code>else</code> in Go is straight-forward.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    if 7%2 == 0 { // (1)!\n        fmt.Println(\"7 is even\")\n    } else {\n        fmt.Println(\"7 is odd\")\n    }\n\n    if 8%4 == 0 { // (2)!\n        fmt.Println(\"8 is divisible by 4\")\n    }\n\n    if 8%2 == 0 || 7%2 == 0 { // (3)!\n        fmt.Println(\"either 8 or 7 are even\")\n    }\n\n    if num := 9; num &lt; 0 { // (4)!\n        fmt.Println(num, \"is negative\")\n    } else if num &lt; 10 {\n        fmt.Println(num, \"has 1 digit\")\n    } else {\n        fmt.Println(num, \"has multiple digits\")\n    }\n}\n</code></pre> <ol> <li>Here\u2019s a basic example.</li> <li>You can have an <code>if</code> statement without an <code>else</code>.</li> <li>Logical operators like <code>&amp;&amp;</code> and <code>||</code> are often useful in conditions.</li> <li>A statement can precede conditionals; any variables declared in this statement are available in the current and all subsequent branches.</li> </ol> Go has no ternary if <p>Go does not have a ternary <code>if</code>, so you\u2019ll need to use a full <code>if</code> statement even for basic conditions.</p> You don\u2019t need parentheses around conditions in Go <p>Parentheses are not required around conditions in Go, but braces are always required.</p>"},{"location":"#switch","title":"Switch","text":"<p>Switch statements express conditionals across many branches.</p> <p></p> <pre><code>package main\n\nimport ( // (1)!\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    i := 2\n    fmt.Print(\"Write \", i, \" as \")\n    switch i { // (2)!\n    case 1:\n        fmt.Println(\"one\")\n    case 2:\n        fmt.Println(\"two\")\n    case 3:\n        fmt.Println(\"three\")\n    }\n\n    switch time.Now().Weekday() { // (3)!\n    case time.Saturday, time.Sunday:\n        fmt.Println(\"It's the weekend\")\n    default:\n        fmt.Println(\"It's a weekday\")\n    }\n\n    t := time.Now()\n    switch { // (4)!\n    case t.Hour() &lt; 12:\n        fmt.Println(\"It's before noon\")\n    default:\n        fmt.Println(\"It's after noon\")\n    }\n\n    whatAmI := func(i interface{}) { // (5)!\n        switch t := i.(type) {\n        case bool:\n            fmt.Println(\"I'm a bool\")\n        case int:\n            fmt.Println(\"I'm an int\")\n        default:\n            fmt.Printf(\"Don't know type %T\\n\", t)\n        }\n    }\n    whatAmI(true)\n    whatAmI(1)\n    whatAmI(\"hey\")\n}\n</code></pre> <ol> <li>Imports can be grouped into a parenthesized, \"factored\" import statement.</li> <li>Here\u2019s a basic switch.</li> <li>You can use commas to separate multiple expressions in the same <code>case</code> statement. We use the optional <code>default</code> case in this example as well.</li> <li><code>switch</code> without an expression is an alternate way to express if/else logic. Here we also show how the <code>case</code> expressions can be non-constants.</li> <li>A type <code>switch</code> compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable <code>t</code> will have the type corresponding     to its clause.</li> </ol> Go\u2019s switch cases break automatically <p>In Go, the <code>break</code> statement is not required in each case of a <code>switch</code> statement. The switch cases break automatically after executing the corresponding code block, making it  easier to write concise and readable code. If you want to fall through to the next case, you can use the <code>fallthrough</code> statement.</p> A switch without expression is an alternate way to express if/else logic. <p>Go allows you to use a <code>switch</code> statement without an expression, which is an alternate way to express if/else logic. This form of <code>switch</code> can be useful for writing concise  conditional statements based on complex conditions.</p> Go\u2019s type switch is a powerful feature for working with interfaces. <p>Go\u2019s type switch allows you to inspect the type of an interface value at runtime and take different actions based on the type. This feature is particularly useful when working  with interfaces and handling values of unknown types.</p>"},{"location":"#arrays","title":"Arrays","text":"<p>In Go, an array is a numbered sequence of elements of a specific length. In typical Go code, slices are much more common; arrays are useful in some special scenarios.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    var a [5]int // (1)!\n    fmt.Println(\"emp:\", a)\n\n    a[4] = 100 // (2)!\n    fmt.Println(\"set:\", a)\n    fmt.Println(\"get:\", a[4])\n\n    fmt.Println(\"len:\", len(a)) // (3)!\n\n    b := [5]int{1, 2, 3, 4, 5} // (4)!\n    fmt.Println(\"dcl:\", b)\n\n    var twoD [2][3]int // (5)!\n    for i := 0; i &lt; 2; i++ {\n        for j := 0; j &lt; 3; j++ {\n            twoD[i][j] = i + j\n        }\n    }\n    fmt.Println(\"2d: \", twoD)\n}\n</code></pre> <ol> <li>Here we create an array a that will hold exactly 5 ints. The type of elements and length are both part of the array\u2019s type. By default an array is zero-valued, which for <code>ints</code>     means 0s.</li> <li>We can set a value at an index using the <code>array[index] = value</code> syntax, and get a value with <code>array[index]</code>.</li> <li>The builtin <code>len</code> returns the length of an array.</li> <li>Use this syntax to declare and initialize an array in one line.</li> <li>Array types are one-dimensional, but you can compose types to build multi-dimensional data structures.</li> </ol> Arrays in Go are fixed-length and zero-valued by default. <p>In Go, arrays are fixed-length sequences of elements with a specific type. The length of an array is part of its type, and arrays are zero-valued by default, meaning that each  element is initialized to the zero value of its type. The fixed-length nature of arrays makes them less flexible than slices, which can grow and shrink dynamically.</p> Go arrays are rarely used directly in practice. <p>While arrays are a fundamental data structure in Go, they are rarely used directly in practice due to their fixed length and limited flexibility. Instead, slices are more  commonly used for working with sequences of elements in Go, as they provide a more dynamic and versatile interface to data.</p> Arrays appear in the form <code>[v1 v2 v3 ...]</code> when printed with <code>fmt.Println</code>."},{"location":"#slices","title":"Slices","text":"<p>Slices are an important data type in Go, giving a more powerful interface to sequences than arrays.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"slices\"\n)\n\nfunc main() {\n\n    var s []string // (1)!\n    fmt.Println(\"uninit:\", s, s == nil, len(s) == 0)\n\n    s = make([]string, 3) // (2)!\n    fmt.Println(\"emp:\", s, \"len:\", len(s), \"cap:\", cap(s))\n\n    s[0] = \"a\" // (3)!\n    s[1] = \"b\"\n    s[2] = \"c\"\n    fmt.Println(\"set:\", s)\n    fmt.Println(\"get:\", s[2])\n\n    fmt.Println(\"len:\", len(s)) // (4)!\n\n    s = append(s, \"d\") // (5)!\n    s = append(s, \"e\", \"f\")\n    fmt.Println(\"apd:\", s)\n\n    c := make([]string, len(s)) // (6)!\n    copy(c, s)\n    fmt.Println(\"cpy:\", c)\n\n    l := s[2:5] // (7)!\n    fmt.Println(\"sl1:\", l)\n\n    l = s[:5] // (8)!\n    fmt.Println(\"sl2:\", l)\n\n    l = s[2:] // (9)!\n    fmt.Println(\"sl3:\", l)\n\n    t := []string{\"g\", \"h\", \"i\"} // (10)!\n    fmt.Println(\"dcl:\", t)\n\n    t2 := []string{\"g\", \"h\", \"i\"} // (11)!\n    if slices.Equal(t, t2) {\n        fmt.Println(\"t == t2\")\n    }\n\n    twoD := make([][]int, 3) // (12)!\n    for i := 0; i &lt; 3; i++ {\n        innerLen := i + 1\n        twoD[i] = make([]int, innerLen)\n        for j := 0; j &lt; innerLen; j++ {\n            twoD[i][j] = i + j\n        }\n    }\n    fmt.Println(\"2d: \", twoD)\n}\n</code></pre> <ol> <li>Unlike arrays, slices are typed only by the elements they contain (not the number of elements). An uninitialized slice equals to nil and has length 0.</li> <li>To create an empty slice with non-zero length, use the builtin <code>make</code>. Here we make a slice of <code>strings</code> of length 3 (initially zero-valued). By default a new slice\u2019s capacity     is equal to its length; if we know the slice is going to grow ahead of time, it\u2019s possible to pass a capacity explicitly as an additional parameter to <code>make</code>.</li> <li>We can set and get just like with arrays.</li> <li><code>len</code> returns the length of the slice as expected.</li> <li>In addition to these basic operations, slices support several more that make them richer than arrays. One is the builtin <code>append</code>, which returns a slice containing one or more     new values. Note that we need to accept a return value from append as we may get a new slice value.</li> <li>Slices can also be copy\u2019d. Here we create an empty slice c of the same length as s and copy into c from s.</li> <li>Slices support a \u201cslice\u201d operator with the syntax <code>slice[low:high]</code>. For example, this gets a slice of the elements <code>s[2]</code>, <code>s[3]</code>, and <code>s[4]</code>.</li> <li>This slices up to (but excluding) <code>s[5]</code>.</li> <li>And this slices up from (and including) <code>s[2]</code>.</li> <li>We can declare and initialize a variable for slice in a single line as well.</li> <li>The <code>slices</code> package contains a number of useful utility functions for slices.</li> <li>Slices can be composed into multi-dimensional data structures. The length of the inner slices can vary, unlike with multi-dimensional arrays.</li> <li>Note that while slices are different types than arrays, they are rendered similarly by <code>fmt.Println</code>.</li> </ol> Slices are the default when working with sequences in Go. <p>Slices are more flexible than arrays in Go, providing a dynamic and versatile interface to sequences of elements. Slices can grow and shrink dynamically, making them suitable  for working with collections of varying sizes and lengths. Slices are commonly used in Go for managing sequences of elements efficiently. The functionality of slices is very similar to the one of <code>std::vector</code> in C++.</p> Slices appear in the form <code>[v1 v2 v3 ...]</code> when printed with <code>fmt.Println</code>."},{"location":"#maps","title":"Maps","text":"<p>Maps are Go\u2019s built-in associative data type (sometimes called hashes or dicts in other languages).</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"maps\"\n)\n\nfunc main() {\n\n    m := make(map[string]int) // (1)!\n\n    m[\"k1\"] = 7 // (2)!\n    m[\"k2\"] = 13\n\n    fmt.Println(\"map:\", m) // (3)!\n\n    v1 := m[\"k1\"] // (4)!\n    fmt.Println(\"v1:\", v1)\n\n    v3 := m[\"k3\"] // (5)!\n    fmt.Println(\"v3:\", v3)\n\n    fmt.Println(\"len:\", len(m)) // (6)!\n\n    delete(m, \"k2\") // (7)!\n    fmt.Println(\"map:\", m)\n\n    clear(m) // (8)!\n    fmt.Println(\"map:\", m)\n\n    _, prs := m[\"k2\"] // (9)!\n    fmt.Println(\"prs:\", prs)\n\n    n := map[string]int{\"foo\": 1, \"bar\": 2} // (10)!\n    fmt.Println(\"map:\", n)\n\n    n2 := map[string]int{\"foo\": 1, \"bar\": 2}\n    if maps.Equal(n, n2) { // (11)!\n        fmt.Println(\"n == n2\")\n    }\n}\n</code></pre> <ol> <li>To create an empty map, use the builtin <code>make</code>: <code>make(map[key-type]val-type)</code>.</li> <li>Set key/value pairs using typical <code>name[key] = val</code> syntax.</li> <li>Printing a map with e.g. <code>fmt.Println</code> will show all of its key/value pairs.</li> <li>Get a value for a key with <code>name[key]</code>.</li> <li>If the key doesn\u2019t exist, the zero value of the value type is returned.</li> <li>The builtin <code>len</code> returns the number of key/value pairs when called on a map.</li> <li>The builtin <code>delete</code> removes key/value pairs from a map.</li> <li>To remove all key/value pairs from a map, use the <code>clear</code> builtin.</li> <li>The optional second return value when getting a value from a map indicates if the key was present in the map. This can be used to disambiguate between missing keys and keys with     zero values like 0 or \"\". Here we didn\u2019t need the value itself, so we ignored it with the blank identifier <code>_</code>.</li> <li>You can also declare and initialize a new map in the same line with this syntax.</li> <li>The <code>maps</code> package contains a number of useful utility functions for maps.</li> </ol> Maps are unordered collections of key/value pairs. <p>Maps in Go are unordered collections of key/value pairs, where each key is unique within the map. Maps provide an efficient way to store and retrieve values based on a key,  making them suitable for implementing associative arrays and dictionaries.</p> Go maps are reference types. <p>Maps in Go are reference types, meaning that when you assign a map to a new variable or pass it as an argument to a function, you are working with a reference to the original  map. This allows you to modify the map's contents and have the changes reflected in all references to the map.</p> Maps appear in the form <code>map[k:v k:v]</code> when printed with <code>fmt.Println</code>."},{"location":"#range","title":"Range","text":"<p>range iterates over elements in a variety of data structures. Let\u2019s see how to use range with some of the data structures we\u2019ve already learned.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    nums := []int{2, 3, 4} // (1)!\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    fmt.Println(\"sum:\", sum)\n\n    for i, num := range nums { // (2)!\n        if num == 3 {\n            fmt.Println(\"index:\", i)\n        }\n    }\n\n    kvs := map[string]string{\"a\": \"apple\", \"b\": \"banana\"} // (3)!\n    for k, v := range kvs {\n        fmt.Printf(\"%s -&gt; %s\\n\", k, v)\n    }\n\n    for k := range kvs { // (4)!\n        fmt.Println(\"key:\", k)\n    }\n\n    for i, c := range \"go\" {\n        fmt.Println(i, c)\n    }   \n}\n</code></pre> <ol> <li>Here we use <code>range</code> to sum the numbers in a slice. Arrays work like this too.</li> <li><code>range</code> on <code>arrays</code> and slices provides both the index and value for each entry. Above we didn\u2019t need the index, so we ignored it with the blank identifier <code>_</code>. Sometimes we     actually want the indexes though.</li> <li><code>range</code> on <code>map</code> iterates over key/value pairs.</li> <li><code>range</code> can also iterate over just the keys of a map.</li> <li><code>range</code> on <code>strings</code> iterates over Unicode code points. The first value is the starting byte index of the rune and the second the rune itself.</li> </ol> The <code>range</code> keyword is used to iterate over elements in data structures. <p>The <code>range</code> keyword in Go is used to iterate over elements in data structures such as arrays, slices, maps, and strings. The <code>range</code> keyword provides a convenient way to loop  over the elements of a data structure without having to manage the index or length explicitly. The <code>range</code> keyword is commonly used in Go for iterating over collections of  elements efficiently.</p> The <code>range</code> keyword returns the index and value of each element. <p>When using the <code>range</code> keyword, Go returns the index and value of each element in the data structure being iterated over. This allows you to access both the index and value of each element within the loop body.</p>"},{"location":"#functions","title":"Functions","text":"<p>Functions are central in Go. We\u2019ll learn about functions with a few different examples.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc plus(a int, b int) int { // (1)!\n\n    return a + b // (2)!\n}\n\nfunc plusPlus(a, b, c int) int { // (3)!\n    return a + b + c\n}\n\nfunc main() {\n\n    res := plus(1, 2) // (4)!\n    fmt.Println(\"1+2 =\", res)\n\n    res = plusPlus(1, 2, 3)\n    fmt.Println(\"1+2+3 =\", res)\n}\n</code></pre> <ol> <li>Here\u2019s a function that takes two <code>ints</code> and returns their sum as an <code>int</code>.</li> <li>Go requires explicit <code>returns</code>, i.e. it won\u2019t automatically return the value of the last expression.</li> <li>When you have multiple consecutive parameters of the same type, you may omit the type name for the like-typed parameters up to the final parameter that declares the type.</li> <li>Call a function just as you\u2019d expect, with <code>name(args)</code>.</li> </ol> Go functions are first-class citizens. <p>Functions in Go are first-class citizens, meaning that functions can be assigned to variables, passed as arguments to other functions, and returned from other functions. This  flexibility allows you to work with functions in a similar way to other data types, making functions a powerful and versatile feature of the language.</p>"},{"location":"#multiple-return-values","title":"Multiple Return Values","text":"<p>Go has built-in support for multiple return values. This feature is used often in idiomatic Go, for example to return both result and error values from a function.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc vals() (int, int) { // (1)!\n    return 3, 7\n}\n\nfunc main() {\n\n    a, b := vals() // (2)!\n    fmt.Println(a)\n    fmt.Println(b)\n\n    _, c := vals() // (3)!\n    fmt.Println(c)\n}   \n</code></pre> <ol> <li>The <code>(int, int)</code> in this function signature shows that the function returns 2 <code>ints</code>.</li> <li>Here we use the 2 different return values from the call with multiple assignment.</li> <li>If you only want a subset of the returned values, use the blank identifier <code>_</code>.</li> </ol> Go functions can return multiple values. <p>Go functions can return multiple values, allowing you to return more than one result from a function. This feature is commonly used to return both the result of a computation  and an error value, enabling functions to provide detailed information about their execution status.</p> Multiple return values are often used to return both a result and an error value from a function. <p>In Go, multiple return values are often used to return both a result and an error value from a function. This pattern allows functions to provide detailed error information when necessary, making it easier to handle errors and exceptions in Go code.</p> The blank identifier <code>_</code> can be used to ignore specific return values when calling a function. <p>When calling a function that returns multiple values, you can use the blank identifier <code>_</code> to ignore specific return values that you are not interested in. This allows you to  focus on the values that are relevant to your code.</p> Named return values can be used to improve code readability. <p>Go allows you to specify named return values in function signatures, which can improve code readability by providing descriptive names for the returned values. Named return  values are particularly useful when a function returns multiple values, making it easier to understand the purpose of each returned value.</p>"},{"location":"#pointers","title":"Pointers","text":"<p>Go supports pointers, allowing you to pass references to values and records within your program.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc zeroval(ival int) { // (1)!\n    ival = 0\n}\n\nfunc zeroptr(iptr *int) { // (2)!\n    *iptr = 0\n}\n\nfunc main() {\n    i := 1\n    fmt.Println(\"initial:\", i)\n\n    zeroval(i)\n    fmt.Println(\"zeroval:\", i)\n\n    zeroptr(&amp;i) // (3)!\n    fmt.Println(\"zeroptr:\", i)\n\n    fmt.Println(\"pointer:\", &amp;i) // (4)!\n}\n</code></pre> <ol> <li>We\u2019ll show how pointers work in contrast to values with 2 functions: <code>zeroval</code> and <code>zeroptr</code>. <code>zeroval</code> has an <code>int</code> parameter, so arguments will be passed to it by value.    <code>zeroval</code> will get a copy of <code>ival</code> distinct from the one in the calling function.</li> <li><code>zeroptr</code> in contrast has an <code>*int</code> parameter, meaning that it takes an int pointer. The <code>*iptr</code> code in the function body then dereferences the pointer from its memory    address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address.</li> <li>The <code>&amp;i</code> syntax gives the memory address of <code>i</code>, i.e. a pointer to <code>i</code>.</li> <li>Pointers can be printed too.</li> </ol> <p><code>zeroval</code> doesn\u2019t change the <code>i</code> in <code>main</code>, but <code>zeroptr</code> does because it has a reference to the memory address for that variable.</p> Go supports pointers for managing memory addresses. <p>Go supports pointers, which are variables that store memory addresses. Pointers allow you to pass references to values and records within your program, enabling you to work with  memory addresses directly. Pointers are commonly used in Go for managing memory efficiently and sharing data between functions.</p> The <code>&amp;</code> operator is used to get the memory address of a variable. The <code>*</code> operator is used to dereference a pointer and access the value at the memory address. Go pointers are used to pass references to values and records. <p>Go pointers are used to pass references to values and records within your program, allowing you to work with memory addresses directly. Pointers provide a way to share data  between functions and manage memory efficiently, making them a powerful feature of the language.</p> Memory allocation in Go is managed by the garbage collector. <p>Go uses a garbage collector to manage memory allocation and deallocation, which means that you do not need to manually allocate or deallocate memory in Go. The garbage collector  automatically reclaims memory that is no longer in use, making memory management easier and more reliable in Go.</p>"},{"location":"#structs","title":"Structs","text":"<p>Go\u2019s structs are typed collections of fields. They\u2019re useful for grouping data together to form records.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\ntype person struct { // (1)!\n    name string\n    age  int\n}\n\nfunc newPerson(name string) *person { // (2)!\n    p := person{name: name}\n    p.age = 42\n    return &amp;p // (3)!\n}\n\nfunc main() {\n    fmt.Println(person{\"Bob\", 20}) // (4)!\n\n    fmt.Println(person{name: \"Alice\", age: 30}) // (5)!\n\n    fmt.Println(person{name: \"Fred\"}) // (6)!\n\n    fmt.Println(&amp;person{name: \"Ann\", age: 40}) // (7)!\n\n    fmt.Println(newPerson(\"Jon\")) // (8)!\n\n    s := person{name: \"Sean\", age: 50}\n    fmt.Println(s.name) // (9)!\n\n    sp := &amp;s\n    fmt.Println(sp.age) // (10)!\n\n    sp.age = 51 // (11)!\n    fmt.Println(sp.age)\n\n    dog := struct { // (12)!\n        name   string\n        isGood bool\n    }{\n        \"Rex\",\n        true,\n    }\n    fmt.Println(dog)\n}\n</code></pre> <ol> <li>This <code>person</code> struct type has <code>name</code> and <code>age</code> fields.</li> <li><code>newPerson</code> constructs a new person struct with the given name.</li> <li>You can safely return a pointer to local variable as a local variable will survive the scope of the function.</li> <li>This syntax creates a new <code>struct</code>.</li> <li>You can name the fields when initializing a struct.</li> <li>Omitted fields will be zero-valued.</li> <li>An <code>&amp;</code> prefix yields a pointer to the struct.</li> <li>It\u2019s idiomatic to encapsulate new struct creation in constructor functions.</li> <li>Access struct fields with a dot.</li> <li>You can also use dots with struct pointers - the pointers are <code>automatically dereferenced</code>.</li> <li>Structs are mutable.</li> <li>If a struct type is only used for a single value, we don\u2019t have to give it a name. The value can have an anonymous struct type.</li> </ol> Go structs can be used to define custom data types. <p>Go structs are used to define custom data types that group together related fields and values. Structs allow you to create complex data structures with multiple fields and  values, enabling you to represent objects and entities in a program. Structs in Go are very similar to structs in C.</p> Go structs are typed collections of fields. <p>Go structs are typed collections of fields that allow you to group data together to form records. Structs are used to define custom data types in Go, enabling you to create  complex data structures with multiple fields and values. Structs are a fundamental feature of Go and are commonly used to represent objects and entities in a program.</p>"},{"location":"#methods","title":"Methods","text":"<p>Go supports methods defined on struct types.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\ntype rect struct {\n    width, height int\n}\n\nfunc (r *rect) area() int { // (1)!\n    return r.width * r.height\n}\n\nfunc (r rect) perim() int { // (2)!\n    return 2*r.width + 2*r.height\n}\n\nfunc main() {\n    r := rect{width: 10, height: 5}\n\n    fmt.Println(\"area: \", r.area()) // (3)!\n    fmt.Println(\"perim:\", r.perim())\n\n    rp := &amp;r // (4)!\n    fmt.Println(\"area: \", rp.area())\n    fmt.Println(\"perim:\", rp.perim())\n}\n</code></pre> <ol> <li>This area method has a receiver type of <code>*rect</code>.</li> <li>Methods can be defined for either pointer or value receiver types. Here\u2019s an example of a value receiver.</li> <li>Here we call the 2 methods defined for our struct.</li> <li>Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the    method to mutate the receiving struct.</li> </ol> Go methods are functions associated with a struct type. <p>Go methods are functions that are associated with a specific struct type. Methods in Go allow you to define functions that operate on struct values, enabling you to encapsulate  behavior and functionality within a struct type. Methods are a powerful feature of Go that allow you to define custom behavior for struct types.</p> Go methods can have pointer or value receivers. <p>Go methods can have either pointer or value receivers, allowing you to define methods that operate on struct values or pointers to struct values. Pointer receivers are commonly  used to avoid copying values when calling methods or to allow methods to modify the receiving struct. Value receivers are used when you want to work with a copy of the struct  value.</p> Go automatically handles conversion between values and pointers for method calls. Go methods can be defined for any named type in Go. <p>Go methods can be defined for any named type in Go, not just structs. This allows you to define methods for custom types, built-in types, and even types from external packages.  Methods in Go provide a flexible way to define behavior for types and enable you to create custom APIs and interfaces for your programs.</p>"},{"location":"#interfaces","title":"Interfaces","text":"<p>Interfaces are named collections of method signatures.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype geometry interface { // (1)!\n    area() float64\n    perim() float64\n}\n\ntype rect struct { // (2)!\n    width, height float64\n}\ntype circle struct {\n    radius float64\n}\n\nfunc (r rect) area() float64 { // (3)!\n    return r.width * r.height\n}\nfunc (r rect) perim() float64 {\n    return 2*r.width + 2*r.height\n}\n\nfunc (c circle) area() float64 { // (4)!\n    return math.Pi * c.radius * c.radius\n}\nfunc (c circle) perim() float64 {\n    return 2 * math.Pi * c.radius\n}\n\nfunc measure(g geometry) { // (5)!\n    fmt.Println(g)\n    fmt.Println(g.area())\n    fmt.Println(g.perim())\n}\n\nfunc main() {\n    r := rect{width: 3, height: 4}\n    c := circle{radius: 5}\n\n    measure(r) // (6)!\n    measure(c)\n}\n</code></pre> <ol> <li>Here\u2019s a basic interface for geometric shapes.</li> <li>For our example we\u2019ll implement this interface on <code>rect</code> and <code>circle</code> types.</li> <li>To implement an interface in Go, we just need to implement all the methods in the interface. Here we implement geometry on <code>rects</code>.</li> <li>The implementation for <code>circles</code>.</li> <li>If a variable has an interface type, then we can call methods that are in the named interface. Here\u2019s a generic measure function taking advantage of this to work on any    <code>geometry</code>.</li> <li>The <code>circle</code> and <code>rect</code> struct types both implement the <code>geometry</code> interface so we can use instances of these structs as arguments to <code>measure</code>.</li> </ol> Go interfaces are named collections of method signatures. <p>Go interfaces are named collections of method signatures that define a set of methods that a type must implement to satisfy the interface. Interfaces in Go provide a way to  define behavior for types without specifying the implementation details, enabling you to define custom APIs and interfaces for your programs.</p> Go interfaces are implemented implicitly. <p>Go interfaces are implemented implicitly, meaning that a type automatically satisfies an interface if it implements all the methods in the interface. This allows you to define  custom behavior for types without explicitly declaring that the type implements the interface. This is fundamentally different from explicit interface implementation in languages you already know like Python, Java and C++.</p>"},{"location":"#struct-embedding","title":"Struct Embedding","text":"<p>Go supports embedding of structs and interfaces to express a more seamless composition of types.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\ntype base struct {\n    num int\n}\n\nfunc (b base) describe() string {\n    return fmt.Sprintf(\"base with num=%v\", b.num)\n}\n\ntype container struct {\n    base // (1)!\n    str string\n}\n\nfunc main() {\n\n    co := container{\n        base: base{ // (2)!\n            num: 1,\n        },\n        str: \"some name\",\n    }\n\n    fmt.Printf(\"co={num: %v, str: %v}\\n\", co.num, co.str) // (3)!\n\n    fmt.Println(\"also num:\", co.base.num) // (4)!\n\n    fmt.Println(\"describe:\", co.describe()) // (5)!\n\n    type describer interface {\n        describe() string\n    }\n\n    var d describer = co // (6)!\n    fmt.Println(\"describer:\", d.describe())\n}\n</code></pre> <ol> <li>A <code>container</code> embeds a <code>base</code>. An embedding looks like a field without a name.</li> <li>When creating structs with literals, we have to initialize the embedding explicitly; here the embedded type serves as the field name.</li> <li>We can access the base\u2019s fields directly on <code>co</code>, e.g. <code>co.num</code>.</li> <li>Alternatively, we can spell out the full path using the embedded type name.</li> <li>Since <code>container</code> embeds <code>base</code>, the methods of <code>base</code> also become methods of a <code>container</code>. Here we invoke a method that was embedded from <code>base</code> directly on <code>co</code>.</li> <li>Embedding structs with methods may be used to bestow interface implementations onto other structs. Here we see that a container now implements the <code>describer</code> interface because    it embeds <code>base</code>.</li> </ol> Go does not support inheritance. <p>Go does not support inheritance or derivation in the traditional sense. Instead, Go uses composition and embedding to achieve code reuse and polymorphism. Embedding  allows you to compose types by including other types as fields within a struct, enabling you to reuse code and behavior across different types.</p> Go interfaces can be implemented implicitly through embedding. <p>Go interfaces can be implemented implicitly through embedding, allowing you to define custom behavior for types without explicitly declaring that the type implements the  interface. This feature makes it easy to define custom APIs and interfaces for your programs, enabling you to work with different types in a seamless and flexible way.</p>"},{"location":"#visibility","title":"Visibility","text":"<p>In Go, visibility is controlled only at the package level. Inside the same package you can access any variable, function, type, etc. without any restrictions. However,  if you want to access an entity from another package, you need to make it exported. An entity is exported if its name starts with a capital letter. When importing a  package, you can only access its exported names, thus everything starting with a capital letter.</p> <p></p> <pre><code>package toto\n\ntype Shape interface { // (1)!\n    SetHeight(height int) // (2)!\n    SetWidth(width int)\n    CalculateArea() int\n}\n\ntype rectangle struct { // (3)!\n    height, width int\n}\n\nfunc NewRectangle(h, w int) Shape { // (4)!\n    return &amp;rectangle{height: h, width: w}\n}\n\nfunc (r *rectangle) SetHeight(height int) { // (5)!\n    r.height = height\n}\n\nfunc (r *rectangle) SetWidth(width int) {\n    r.width = width\n}\n\nfunc (r *rectangle) CalculateArea() int {\n    return r.height * r.width\n}\n</code></pre> <ol> <li>In this example, the <code>Shape</code> interface is exported because its name starts with a capital letter.</li> <li>All methods of the Shape interface are exported because they start with a capital letter too.</li> <li>The <code>rectangle</code> struct is not exported because its name starts with a lowercase letter. </li> <li>The <code>NewRectangle</code> function is exported because its name starts with a capital letter.</li> <li>All methods of the <code>rectangle</code> struct are exported because their names start with a capital letter.</li> </ol> <p>Go visibility is controlled at the package level.</p> Exported names in Go start with a capital letter. <p>In Go, exported names start with a capital letter, while unexported names start with a lowercase letter. Exported names are accessible from other packages, while unexported  names are only accessible within the same package.</p>"},{"location":"#errors","title":"Errors","text":"<p>In Go it\u2019s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Python, Java and C++ and the overloaded single result / error value sometimes used in C. Go\u2019s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for other, non-error tasks.</p> <p></p> <p>See the documentation of the <code>errors</code> package for additional details.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc f(arg int) (int, error) { // (1)!\n    if arg == 42 {\n        return -1, errors.New(\"can't work with 42\") // (2)!\n    }\n\n    return arg + 3, nil // (3)!\n}\n\nvar ErrOutOfTea = fmt.Errorf(\"no more tea available\") // (4)!\nvar ErrPower = fmt.Errorf(\"can't boil water\")\n\nfunc makeTea(arg int) error {\n    if arg == 2 {\n        return ErrOutOfTea\n    } else if arg == 4 {\n\n        return fmt.Errorf(\"making tea: %w\", ErrPower) // (5)!\n    }\n    return nil\n}\n\nfunc main() {\n    for _, i := range []int{7, 42} {\n\n        if r, e := f(i); e != nil { // (6)!\n            fmt.Println(\"f failed:\", e)\n        } else {\n            fmt.Println(\"f worked:\", r)\n        }\n    }\n\n    for i := range 5 {\n        if err := makeTea(i); err != nil {\n\n            if errors.Is(err, ErrOutOfTea) { // (7)!\n                fmt.Println(\"We should buy new tea!\")\n            } else if errors.Is(err, ErrPower) {\n                fmt.Println(\"Now it is dark.\")\n            } else {\n                fmt.Printf(\"unknown error: %s\\n\", err)\n            }\n            continue\n        }\n\n        fmt.Println(\"Tea is ready!\")\n    }\n}\n</code></pre> <ol> <li>By convention, errors are the last return value and have type <code>error</code>, a built-in interface.</li> <li>errors.New constructs a basic error value with the given error message.</li> <li>A <code>nil</code> value in the <code>error</code> position indicates that there was no error.</li> <li>A sentinel error is a predeclared variable that is used to signify a specific error condition.</li> <li>We can wrap errors with higher-level errors to add context. The simplest way to do this is with the <code>%w</code> verb in <code>fmt.Errorf</code>. Wrapped errors create a logical chain (A wraps B,    which wraps C, etc.) that can be queried with functions like <code>errors.Is</code> and <code>errors.As</code>.</li> <li>It\u2019s common to use an inline error check in the <code>if</code> line.</li> <li><code>errors.Is</code> checks that a given <code>error</code> (or any error in its chain) matches a specific <code>error</code> value. This is especially useful with wrapped or nested errors, allowing you to    identify specific error types or sentinel errors in a chain of errors.</li> </ol> Go uses explicit error handling instead of exceptions. <p>Go uses explicit error handling instead of exceptions to manage errors in programs. By returning errors as separate values from functions, Go makes it easy to see which functions return errors and to handle them using the same language constructs employed for other tasks. This approach simplifies error handling and makes it easier to write robust and  reliable code.</p> Go uses sentinel errors to represent specific error conditions. <p>Go uses sentinel errors, which are predeclared variables that represent specific error conditions, to signify common error states in programs. Sentinel errors are used to  communicate specific error conditions to the caller and to provide a consistent way to handle errors in Go code.</p>"},{"location":"#panic","title":"Panic","text":"<p>A panic typically means something went unexpectedly wrong. Mostly we use it to fail fast on errors that shouldn\u2019t occur during normal operation, or that we aren\u2019t prepared to  handle gracefully.</p> <p></p> <pre><code>package main\n\nimport \"os\"\n\nfunc main() {\n\n    panic(\"a problem\") // (1)!\n\n    _, err := os.Create(\"/tmp/file\") // (2)!\n    if err != nil {\n        panic(err)\n    }\n}\n</code></pre> <ol> <li>Terminates the program with a non-zero exit code. This is a common way to stop execution if a function returns an error value that we don\u2019t know how to (or want to) handle.</li> <li>A common use of panic is to abort if a function returns an error value that we don\u2019t know how to (or want to) handle. Here\u2019s an example of panicking if we get an unexpected     error when creating a new file.</li> </ol> <p>Running this program will cause it to panic, print an error message and goroutine traces, and exit with a non-zero status. When first panic in main fires, the program exits  without reaching the rest of the code. If you\u2019d like to see the program try to create a temp file, comment the first panic out.</p> Go panics are used to stop execution on unexpected errors. <p>Go panics are used to stop execution on unexpected errors that should not occur during normal operation. Panics are typically used to fail fast on errors that cannot be handled  gracefully, allowing you to stop the program and print an error message before exiting. Panics are a powerful tool for handling unexpected errors in Go programs.</p> Go panics terminate the program with a non-zero exit code."},{"location":"#defer","title":"Defer","text":"<p>Defer is used to ensure that a function call is performed later in a program\u2019s execution, usually for purposes of cleanup. <code>defer</code> is often used where e.g. ensure and finally would be used in other languages.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() { // (1)!\n\n    f := createFile(\"/tmp/defer.txt\")\n    defer closeFile(f) // (2)!\n    writeFile(f)\n}\n\nfunc createFile(p string) *os.File {\n    fmt.Println(\"creating\")\n    f, err := os.Create(p)\n    if err != nil {\n        panic(err)\n    }\n    return f\n}\n\nfunc writeFile(f *os.File) {\n    fmt.Println(\"writing\")\n    fmt.Fprintln(f, \"data\")\n\n}\n\nfunc closeFile(f *os.File) { // (3)!\n    fmt.Println(\"closing\")\n    err := f.Close()\n\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n        os.Exit(1)\n    }\n}\n</code></pre> <ol> <li>Suppose we wanted to create a file, write to it, and then close when we\u2019re done. Here\u2019s how we could do that with <code>defer</code>.</li> <li>Immediately after getting a file object with <code>createFile</code>, we <code>defer</code> the closing of that file with <code>closeFile</code>. This will be executed at the end of the enclosing function     (main), after <code>writeFile</code> has finished.</li> <li>It\u2019s important to check for errors when closing a file, even in a deferred function.</li> </ol> <p>Running the program confirms that the file is closed after being written.</p> Go defer statements are used to ensure cleanup actions are performed. <p>Go defer statements are used to ensure that cleanup actions are performed at the end of a function, regardless of how the function exits. Defer statements are commonly used to  close resources, release locks, and perform other cleanup tasks that need to be executed before a function returns.</p> <p>Go defer statements are executed in reverse order.</p>"},{"location":"#string-functions","title":"String Functions","text":"<p>The standard library\u2019s <code>strings</code> package provides many useful string-related functions. Here are some examples to give you a sense of the package.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    s \"strings\"\n)\n\nvar p = fmt.Println // (1)!\n\nfunc main() {\n\n    p(\"Contains:  \", s.Contains(\"test\", \"es\")) // (2)!\n    p(\"Count:     \", s.Count(\"test\", \"t\"))\n    p(\"HasPrefix: \", s.HasPrefix(\"test\", \"te\"))\n    p(\"HasSuffix: \", s.HasSuffix(\"test\", \"st\"))\n    p(\"Index:     \", s.Index(\"test\", \"e\"))\n    p(\"Join:      \", s.Join([]string{\"a\", \"b\"}, \"-\"))\n    p(\"Repeat:    \", s.Repeat(\"a\", 5))\n    p(\"Replace:   \", s.Replace(\"foo\", \"o\", \"0\", -1))\n    p(\"Replace:   \", s.Replace(\"foo\", \"o\", \"0\", 1))\n    p(\"Split:     \", s.Split(\"a-b-c-d-e\", \"-\"))\n    p(\"ToLower:   \", s.ToLower(\"TEST\"))\n    p(\"ToUpper:   \", s.ToUpper(\"test\"))\n}\n</code></pre> <ol> <li>We alias <code>fmt.Println</code> to a shorter name as we\u2019ll use it a lot below.</li> <li>Here\u2019s a sample of the functions available in strings. Since these are functions from the package, not methods on the string object itself, we need pass the string in question     as the first argument to the function. You can find more functions in the strings package docs.</li> </ol> Go strings package provides many useful functions for working with strings. <p>The Go strings package provides many useful functions for working with strings, including functions for searching, replacing, splitting, and transforming strings. The strings  package is part of the Go standard library and is commonly used in Go programs to manipulate and process string data.</p>"},{"location":"#string-formatting","title":"String Formatting","text":"<p>Go offers support for string formatting in the <code>printf</code> tradition. Here are some examples of common string formatting tasks.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\ntype point struct {\n    x, y int\n}\n\nfunc main() {\n\n    p := point{1, 2}\n    fmt.Printf(\"struct1: %v\\n\", p) // (1)!\n\n    fmt.Printf(\"struct2: %+v\\n\", p) // (2)!\n\n    fmt.Printf(\"struct3: %#v\\n\", p) // (3)!\n\n    fmt.Printf(\"type: %T\\n\", p) // (4)!\n\n    fmt.Printf(\"bool: %t\\n\", true) // (5)!\n\n    fmt.Printf(\"int: %d\\n\", 123) // (6)!\n\n    fmt.Printf(\"bin: %b\\n\", 14) // (7)!\n\n    fmt.Printf(\"char: %c\\n\", 33) // (8)!\n\n    fmt.Printf(\"hex: %x\\n\", 456) // (9)!\n\n    fmt.Printf(\"float1: %f\\n\", 78.9) // (10)!\n\n    fmt.Printf(\"float2: %e\\n\", 123400000.0) // (11)!\n    fmt.Printf(\"float3: %E\\n\", 123400000.0)\n\n    fmt.Printf(\"str1: %s\\n\", \"string\") // (12)!\n\n    fmt.Printf(\"str2: %q\\n\", \"string\") // (13)!\n\n    fmt.Printf(\"str3: %x\\n\", \"hex this\") // (14)!\n\n    fmt.Printf(\"pointer: %p\\n\", &amp;p) // (15)!\n\n    fmt.Printf(\"width1: |%6d|%6d|\\n\", 12, 345) // (16)!\n\n    fmt.Printf(\"width2: |%6.2f|%6.2f|\\n\", 1.2, 3.45) // (17)!\n\n    fmt.Printf(\"width3: |%-6.2f|%-6.2f|\\n\", 1.2, 3.45) // (18)!\n\n    fmt.Printf(\"width4: |%6s|%6s|\\n\", \"foo\", \"b\") // (19)!\n\n    fmt.Printf(\"width5: |%-6s|%-6s|\\n\", \"foo\", \"b\") // (20)!\n\n    s := fmt.Sprintf(\"sprintf: a %s\", \"string\") // (21)!\n    fmt.Println(s)\n\n    fmt.Fprintf(os.Stderr, \"io: an %s\\n\", \"error\") // (22)!\n}\n</code></pre> <ol> <li>Go offers several printing \u201cverbs\u201d designed to format general Go values. For example, this prints an instance of our <code>point</code> struct.</li> <li>If the value is a struct, the <code>%+v</code> variant will include the struct\u2019s field names.</li> <li>The <code>%#v</code> variant prints a Go syntax representation of the value, i.e. the source code snippet that would produce that value.</li> <li>To print the type of a value, use <code>%T</code>.</li> <li>Formatting booleans is straight-forward.</li> <li>There are many options for formatting integers. Use <code>%d</code> for standard, base-10 formatting.</li> <li>This prints a binary representation of the integer.</li> <li>This prints the character corresponding to the given integer.</li> <li><code>%x</code> provides hex encoding.</li> <li>There are also several formatting options for floats. For basic decimal formatting use <code>%f</code>.</li> <li><code>%e</code> and <code>%E</code> format the float in (slightly different versions of) scientific notation.</li> <li>For basic string printing use <code>%s</code>.</li> <li>To double-quote strings as in Go source, use <code>%q</code>.</li> <li>As with integers seen earlier, <code>%x</code> renders the string in base-16, with two output characters per byte of input.</li> <li>To print a representation of a pointer, use <code>%p</code>.</li> <li>When formatting numbers you will often want to control the width and precision of the resulting figure. To specify the width of an integer, use a number after the <code>%</code> in the     verb. By default, the result will be right-justified and padded with spaces.</li> <li>You can also specify the width of printed floats, though usually you\u2019ll also want to restrict the decimal precision at the same time with the <code>width.precision</code> syntax.</li> <li>To left-justify, use the <code>-</code> flag.</li> <li>You may also want to control width when formatting strings, especially to ensure that they align in table-like output. For basic right-justified width.</li> <li>To left-justify use the <code>-</code> flag as with numbers.</li> <li>So far we\u2019ve seen <code>Printf</code>, which prints the formatted string to <code>os.Stdout</code>. <code>Sprintf</code> formats and returns a string without printing it anywhere.</li> <li>You can format+print to<code>io.Writers</code> other than <code>os.Stdout</code> using <code>Fprintf</code>.</li> </ol>"},{"location":"#json-encoding-and-decoding","title":"JSON Encoding and Decoding","text":"<p>Go offers built-in support for JSON encoding and decoding, including to and from built-in and custom data types.</p> <p></p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype response1 struct { // (1)!\n    Page   int  // (2)!\n    Fruits []string\n}\n\ntype response2 struct {\n    Page   int      `json:\"page\"` // (3)!\n    Fruits []string `json:\"fruits\"`\n}\n\nfunc main() {\n\n    bolB, _ := json.Marshal(true) // (4)!\n    fmt.Println(string(bolB))\n\n    intB, _ := json.Marshal(1)\n    fmt.Println(string(intB))\n\n    fltB, _ := json.Marshal(2.34)\n    fmt.Println(string(fltB))\n\n    strB, _ := json.Marshal(\"gopher\")\n    fmt.Println(string(strB))\n\n    slcD := []string{\"apple\", \"peach\", \"pear\"} // (5)!\n    slcB, _ := json.Marshal(slcD)\n    fmt.Println(string(slcB))\n\n    mapD := map[string]int{\"apple\": 5, \"lettuce\": 7}\n    mapB, _ := json.Marshal(mapD)\n    fmt.Println(string(mapB))\n\n    res1D := &amp;response1{ // (6)!\n        Page:   1,\n        Fruits: []string{\"apple\", \"peach\", \"pear\"}}\n    res1B, _ := json.Marshal(res1D)\n    fmt.Println(string(res1B))\n\n    res2D := &amp;response2{\n        Page:   1,\n        Fruits: []string{\"apple\", \"peach\", \"pear\"}}\n    res2B, _ := json.Marshal(res2D)\n    fmt.Println(string(res2B))\n\n    byt := []byte(`{\"num\":6.13,\"strs\":[\"a\",\"b\"]}`) // (7)!\n\n    var dat map[string]interface{} // (8)!\n\n    if err := json.Unmarshal(byt, &amp;dat); err != nil { // (9)!\n        panic(err)\n    }\n    fmt.Println(dat)\n\n    num := dat[\"num\"].(float64) // (10)!\n    fmt.Println(num)\n\n    strs := dat[\"strs\"].([]interface{}) // (11)!\n    str1 := strs[0].(string)\n    fmt.Println(str1)\n\n    str := `{\"page\": 1, \"fruits\": [\"apple\", \"peach\"]}` // (12)!\n    res := response2{}\n    json.Unmarshal([]byte(str), &amp;res)\n    fmt.Println(res)\n    fmt.Println(res.Fruits[0])\n\n    enc := json.NewEncoder(os.Stdout) // (13)!\n    d := map[string]int{\"apple\": 5, \"lettuce\": 7}\n    enc.Encode(d)\n}\n</code></pre> <ol> <li>We\u2019ll use these two <code>structs</code> to demonstrate encoding and decoding of custom types below.</li> <li>Only exported fields will be encoded/decoded in JSON. Fields must start with capital letters to be exported.</li> <li>You can use tags on struct field declarations to customize the encoded JSON key names.</li> <li>First we\u2019ll look at encoding basic data types to JSON strings. Here are some examples for atomic values.</li> <li>And here are some for slices and maps, which encode to JSON arrays and objects as you\u2019d expect.</li> <li>The <code>JSON</code> package can automatically encodes your custom data types. It will only include exported fields in the encoded output and will by default use those names as the JSON     keys.</li> <li>Now let\u2019s look at decoding JSON data into Go values. Here\u2019s an example for a generic data structure.</li> <li>We need to provide a variable where the <code>JSON</code> package can put the decoded data. This <code>map[string]interface{}</code> will hold a map of strings to arbitrary data types.</li> <li>Here\u2019s the actual decoding, and a check for associated errors.</li> <li>In order to use the values in the decoded map, we\u2019ll need to convert them to their appropriate type. For example here we convert the value in num to the expected float64 type.</li> <li>Accessing nested data requires a series of conversions.</li> <li>We can also decode JSON into custom data types. This has the advantages of adding additional type-safety to our programs and eliminating the need for type assertions when      accessing the decoded data.</li> <li>In the examples above we always used bytes and strings as intermediates between the data and JSON representation on standard out. We can also stream JSON encodings directly      to <code>os.Writers</code> like <code>os.Stdout</code> or even HTTP response bodies.</li> </ol> Go JSON package provides functions for encoding and decoding JSON data. <p>The Go <code>JSON</code> package provides functions for encoding and decoding JSON data, enabling you to convert Go data structures to JSON strings and vice versa. The JSON package is  part of the Go standard library and is commonly used in Go programs to work with JSON data.</p> Go JSON encoding and decoding supports custom data types. <p>Go JSON encoding and decoding supports custom data types, allowing you to encode and decode custom data structures to and from JSON strings. This enables you to work with JSON  data in a type-safe and flexible way, making it easy to serialize and deserialize data in your programs. Only exported fields will be encoded/decoded in JSON though.</p> Go JSON encoding and decoding supports custom key names. <p>Go JSON encoding and decoding supports custom key names using struct tags, allowing you to customize the encoded JSON key names for struct fields. This enables you to control  how struct fields are encoded and decoded to and from JSON strings, providing a flexible way to work with JSON data in Go.</p>"},{"location":"#time","title":"Time","text":"<p>Go offers extensive support for times and durations. Here are some examples.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    p := fmt.Println\n\n    now := time.Now() // (1)!\n    p(now)\n\n    then := time.Date( // (2)!\n        2009, 11, 17, 20, 34, 58, 651387237, time.UTC)\n    p(then)\n\n    p(then.Year()) // (3)!\n    p(then.Month())\n    p(then.Day())\n    p(then.Hour())\n    p(then.Minute())\n    p(then.Second())\n    p(then.Nanosecond())\n    p(then.Location())\n\n    p(then.Weekday()) // (4)!\n\n    p(then.Before(now)) // (5)!\n    p(then.After(now))\n    p(then.Equal(now))\n\n    diff := now.Sub(then) // (6)!\n    p(diff)\n\n    p(diff.Hours()) // (7)!\n    p(diff.Minutes())\n    p(diff.Seconds())\n    p(diff.Nanoseconds())\n\n    p(then.Add(diff)) // (8)!\n    p(then.Add(-diff))\n\n    p(now.Unix()) // (9)!\n    p(now.UnixMilli())\n    p(now.UnixNano())\n\n    p(time.Unix(now.Unix(), 0)) // (10)!\n    p(time.Unix(0, now.UnixNano()))\n}\n</code></pre> <ol> <li>We\u2019ll start by getting the current time.</li> <li>You can build a <code>time</code> struct by providing the year, month, day, etc. Times are always associated with a <code>Location</code>, i.e. time zone.</li> <li>You can extract the various components of the time value as expected.</li> <li>The Monday-Sunday Weekday is also available.</li> <li>These methods compare two times, testing if the first occurs before, after, or at the same time as the second, respectively.</li> <li>The <code>Sub</code> methods returns a <code>Duration</code> representing the interval between two times.</li> <li>We can compute the length of the duration in various units.</li> <li>You can use <code>Add</code> to advance a time by a given duration, or with a - to move backwards by a duration.</li> <li>Use <code>time</code> with <code>Unix</code>, <code>UnixMilli</code> or <code>UnixNano</code> to get elapsed time since the Unix epoch in seconds, milliseconds or nanoseconds, respectively.</li> <li>You can also convert integer seconds or nanoseconds since the epoch into the corresponding <code>time</code>.</li> </ol> Go time package provides extensive support for working with times and durations. <p>The Go <code>time</code> package provides extensive support for working with times and durations, enabling you to manipulate and format time values, calculate time intervals, and perform  time-based operations in your programs. The <code>time</code> package is part of the Go standard library and is commonly used in Go programs to handle time-related tasks.</p> Go time values are always associated with a location. <p>Go time values are always associated with a location, which specifies the time zone and daylight saving time rules for the time value. UTC is the default location for time values in Go, but you can specify a different location when creating a time value using the <code>time.Date</code> function.</p> Go time values can be converted from and to Unix epoch. <p>Go time values can be converted from and to the Unix epoch, which is the number of seconds or nanoseconds that have elapsed since January 1, 1970 UTC. This allows you to work  with time values in a standard format that is widely used in computing.</p>"},{"location":"#number-parsing","title":"Number Parsing","text":"<p>Parsing numbers from strings is a basic but common task in many programs; here\u2019s how to do it in Go.</p> <p></p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\" // (1)!\n)\n\nfunc main() {\n\n    f, _ := strconv.ParseFloat(\"1.234\", 64) // (2)!\n    fmt.Println(f)\n\n    i, _ := strconv.ParseInt(\"123\", 0, 64) // (3)!\n    fmt.Println(i)\n\n    d, _ := strconv.ParseInt(\"0x1c8\", 0, 64) // (4)!\n    fmt.Println(d)\n\n    u, _ := strconv.ParseUint(\"789\", 0, 64) // (5)!\n    fmt.Println(u)\n\n    k, _ := strconv.Atoi(\"135\") // (6)!\n    fmt.Println(k)\n\n    _, e := strconv.Atoi(\"wat\") // (7)!\n    fmt.Println(e)\n}\n</code></pre> <ol> <li>The built-in package <code>strconv</code> provides the number parsing.</li> <li>With <code>ParseFloat</code>, this <code>64</code> tells how many bits of precision to parse.</li> <li>For <code>ParseInt</code>, the <code>0</code> means infer the base from the string. <code>64</code> requires that the result fit in 64 bits.</li> <li><code>ParseInt</code> will recognize hex-formatted numbers.</li> <li><code>ParseUint</code> is also available.</li> <li><code>Atoi</code> is a convenience function for basic base-10 <code>int</code> parsing.</li> <li>Parse functions return an <code>error</code> on bad input.</li> </ol> Go strconv package provides functions for parsing numbers from strings. <p>The Go <code>strconv</code> package provides functions for parsing numbers from strings, including functions for parsing integers, floating-point numbers, and other numeric values. The  <code>strconv</code> package is part of the Go standard library and is commonly used in Go programs to convert string representations of numbers into numeric values.</p>"},{"location":"#advanced-topics","title":"Advanced Topics","text":""},{"location":"#embed-directive","title":"Embed Directive","text":"<p><code>//go:embed</code> is a compiler directive that allows programs to include arbitrary files and folders in the Go binary at build time.</p> <p></p> <pre><code>package main\n\nimport (\n    \"embed\" // (1)!\n)\n\n//go:embed folder/single_file.txt (2)\nvar fileString string\n\n//go:embed folder/single_file.txt (3)\nvar fileByte []byte\n\n//go:embed folder/single_file.txt (4)\n//go:embed folder/*.hash\nvar folder embed.FS\n\nfunc main() {\n\n    print(fileString) // (5)!\n    print(string(fileByte))\n\n    content1, _ := folder.ReadFile(\"folder/file1.hash\") // (6)!\n    print(string(content1))\n\n    content2, _ := folder.ReadFile(\"folder/file2.hash\")\n    print(string(content2))\n}\n</code></pre> <ol> <li>Import the <code>embed</code> package; if you don\u2019t use any exported identifiers from this package, you can do a blank import with _<code>\"embed\"</code>.</li> <li><code>embed</code> directives accept paths relative to the directory containing the Go source file. This directive embeds the contents of the file into the string variable immediately     following it.</li> <li>Or embed the contents of the file into a <code>[]byte</code>.</li> <li>We can also embed multiple files or even folders with wildcards. This uses a variable of the <code>embed.FS</code> type, which implements a simple virtual file system.</li> <li>Print out the contents of <code>single_file.txt</code>.</li> <li>Retrieve some files from the embedded folder.</li> </ol>"},{"location":"#variadic-functions","title":"Variadic Functions","text":"<p>Variadic functions can be called with any number of trailing arguments. For example, <code>fmt.Println</code> is a common variadic function.</p> <p></p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc sum(nums ...int) { // (1)!\n    fmt.Print(nums, \" \")\n    total := 0\n\n    for _, num := range nums { // (2)!\n        total += num\n    }\n    fmt.Println(total)\n}\n\nfunc main() {\n\n    sum(1, 2) // (3)!\n    sum(1, 2, 3)\n\n    nums := []int{1, 2, 3, 4}\n    sum(nums...) // (4)!\n}\n</code></pre> <ol> <li>Here\u2019s a function that will take an arbitrary number of <code>ints</code> as arguments.</li> <li>Within the function, the type of nums is equivalent to <code>[]int</code>. We can call <code>len(nums)</code>, iterate over it with <code>range</code>, etc.</li> <li>Variadic functions can be called in the usual way with individual arguments.</li> <li>If you already have multiple args in a slice, apply them to a variadic function using <code>func(slice...)</code> like this.</li> </ol> <p>Another key aspect of functions in Go is their ability to form closures, which we\u2019ll look at next.</p>"},{"location":"#closures","title":"Closures","text":"<p>Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc intSeq() func() int { // (1)!\n    i := 0\n    return func() int {\n        i++\n        return i\n    }\n}\n\nfunc main() {\n\n    nextInt := intSeq() // (2)!\n\n    fmt.Println(nextInt()) // (3)!\n    fmt.Println(nextInt())\n    fmt.Println(nextInt())\n\n    newInts := intSeq() // (4)!\n    fmt.Println(newInts())\n}\n</code></pre> <ol> <li>This function <code>intSeq</code> returns another function, which we define anonymously in the body of <code>intSeq</code>. The returned function closes over the variable <code>i</code> to form a closure.</li> <li>We call <code>intSeq</code>, assigning the result (a function) to <code>nextInt</code>. This function value captures its own <code>i</code> value, which will be updated each time we call <code>nextInt</code>.</li> <li>See the effect of the closure by calling <code>nextInt</code> a few times.</li> <li>To confirm that the state is unique to that particular function, create and test a new one.</li> </ol> <p>The last feature of functions we\u2019ll look at for now is recursion.</p>"},{"location":"#recursion","title":"Recursion","text":"<p>Go supports recursive functions. Here\u2019s a classic example.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc fact(n int) int { // (1)!\n    if n == 0 {\n        return 1\n    }\n    return n * fact(n-1)\n}\n\nfunc main() {\n    fmt.Println(fact(7))\n\n    var fib func(n int) int // (2)!\n\n    fib = func(n int) int {\n        if n &lt; 2 {\n            return n\n        }\n\n        return fib(n-1) + fib(n-2) // (3)!\n    }\n\n    fmt.Println(fib(7))\n}\n</code></pre> <ol> <li>This <code>fact</code> function calls itself until it reaches the base case of <code>fact(0)</code>.</li> <li>Closures can also be recursive, but this requires the closure to be declared with a typed <code>var</code> explicitly before it\u2019s defined.</li> <li>Since <code>fib</code> was previously declared in <code>main</code>, Go knows which function to call with <code>fib</code> here.</li> </ol>"},{"location":"#strings-and-runes","title":"Strings and Runes","text":"<p>A Go string is a read-only slice of bytes. The language and the standard library treat strings specially - as containers  of text encoded in UTF-8. In other languages, strings are made of \u201ccharacters\u201d. In Go, the concept of a character is  called a rune - it\u2019s an integer that represents a Unicode code point. </p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n\n    const s = \"\u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35\" // (1)!\n\n    fmt.Println(\"Len:\", len(s)) // (2)!\n\n    for i := 0; i &lt; len(s); i++ { // (3)!\n        fmt.Printf(\"%x \", s[i])\n    }\n    fmt.Println()\n\n    fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) // (4)!\n\n    for idx, runeValue := range s { // (5)!\n        fmt.Printf(\"%#U starts at %d\\n\", runeValue, idx)\n    }\n\n    fmt.Println(\"\\nUsing DecodeRuneInString\")\n    for i, w := 0, 0; i &lt; len(s); i += w {\n        runeValue, width := utf8.DecodeRuneInString(s[i:]) // (6)!\n        fmt.Printf(\"%#U starts at %d\\n\", runeValue, i)\n        w = width\n\n        examineRune(runeValue) // (7)!\n    }\n}\n\nfunc examineRune(r rune) {\n    if r == 't' { // (8)!\n        fmt.Println(\"found tee\")\n    } else if r == '\u0e2a' {\n        fmt.Println(\"found so sua\")\n    }\n}\n</code></pre> <ol> <li><code>s</code> is a <code>string</code> assigned a literal value representing the word \u201chello\u201d in the Thai language. Go string literals are UTF-8 encoded text.</li> <li>Since <code>strings</code> are equivalent to <code>[]byte</code>, this will produce the length of the raw bytes stored within.</li> <li>Indexing into a <code>string</code> produces the raw byte values at each index. This loop generates the hex values of all the bytes that constitute the code points in <code>s</code>.</li> <li>To count how many runes are in a <code>string</code>, we can use the <code>utf8</code> package. Note that the run-time of <code>RuneCountInString</code> depends on the size of the string, because it has to     decode each UTF-8 rune sequentially. Some Thai characters are represented by UTF-8 code points that can span multiple bytes, so the result of this count may be surprising.</li> <li>A <code>range</code> loop handles strings specially and decodes each rune along with its offset in the string.</li> <li>We can achieve the same iteration by using the <code>utf8.DecodeRuneInString</code> function explicitly.</li> <li>This demonstrates passing a <code>rune</code> value to a function.</li> <li>Values enclosed in single quotes are rune literals. We can compare a <code>rune</code> value to a <code>rune</code> literal directly.</li> </ol>"},{"location":"#generics","title":"Generics","text":"<p>Starting with version 1.18, Go has added support for generics, also known as type parameters.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc MapKeys[K comparable, V any](m map[K]V) []K { // (1)!\n    r := make([]K, 0, len(m))\n    for k := range m {\n        r = append(r, k)\n    }\n    return r\n}\n\ntype List[T any] struct { // (2)!\n    head, tail *element[T]\n}\n\ntype element[T any] struct {\n    next *element[T]\n    val  T\n}\n\nfunc (lst *List[T]) Push(v T) { // (3)!\n    if lst.tail == nil {\n        lst.head = &amp;element[T]{val: v}\n        lst.tail = lst.head\n    } else {\n        lst.tail.next = &amp;element[T]{val: v}\n        lst.tail = lst.tail.next\n    }\n}\n\nfunc (lst *List[T]) GetAll() []T {\n    var elems []T\n    for e := lst.head; e != nil; e = e.next {\n        elems = append(elems, e.val)\n    }\n    return elems\n}\n\nfunc main() {\n    var m = map[int]string{1: \"2\", 2: \"4\", 4: \"8\"}\n\n    fmt.Println(\"keys:\", MapKeys(m)) // (4)!\n\n    _ = MapKeys[int, string](m) // (5)!\n\n    lst := List[int]{}\n    lst.Push(10)\n    lst.Push(13)\n    lst.Push(23)\n    fmt.Println(\"list:\", lst.GetAll())\n}\n</code></pre> <ol> <li>As an example of a generic function, <code>MapKeys</code> takes a map of any type and returns a slice of its keys. This function has two type parameters - <code>K</code> and <code>V</code>; <code>K</code> has the     <code>comparable</code> constraint, meaning that we can compare values of this type with the <code>==</code> and <code>!=</code> operators. This is required for map keys in Go. <code>V</code> has the <code>any</code> constraint,     meaning that it\u2019s not restricted in any way (<code>any</code> is an alias for <code>interface{}</code>).</li> <li>As an example of a generic type, <code>List</code> is a singly-linked list with values of <code>any</code> type.</li> <li>We can define methods on generic types just like we do on regular types, but we have to keep the type parameters in place. The type is <code>List[T]</code>, not <code>List</code>.</li> <li>When invoking generic functions, we can often rely on type inference. Note that we don\u2019t have to specify the types for <code>K</code> and <code>V</code> when calling <code>MapKeys</code> - the compiler infers     them automatically.</li> <li>We could also specify the types explicitly.</li> </ol> Go generics allow you to write reusable code that works with any type. <p>Go generics allow you to write reusable code that works with any type, enabling you to create generic functions, types, and methods that can be used with a wide range of data  types. Generics in Go provide a flexible way to write code that is more generic and reusable, making it easier to work with different types in a consistent and efficient way. As Go supports type parameters with constraints, this allows you to specify requirements for the types that can be used with a generic function, type, or method. This provides  a way to ensure that the types used with a generic construct meet specific criteria, such as implementing specific methods or interfaces.</p> Go generics support type inference for generic functions. <p>Go generics support type inference for generic functions, allowing you to call a generic function without specifying the type parameters explicitly. The Go compiler can infer  the types of the arguments based on the context in which the function is called, making it easier to write generic code that is concise and readable.</p>"},{"location":"#custom-errors","title":"Custom Errors","text":"<p>It\u2019s possible to use custom types as errors by implementing the <code>Error()</code> method on them.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\ntype argError struct { // (1)!\n    arg     int\n    message string\n}\n\nfunc (e *argError) Error() string { // (2)!\n    return fmt.Sprintf(\"%d - %s\", e.arg, e.message)\n}\n\nfunc f(arg int) (int, error) {\n    if arg == 42 {\n\n        return -1, &amp;argError{arg, \"can't work with it\"} // (3)!\n    }\n    return arg + 3, nil\n}\n\nfunc main() {\n\n    _, err := f(42)\n    var ae *argError\n    if errors.As(err, &amp;ae) { // (4)!\n        fmt.Println(ae.arg)\n        fmt.Println(ae.message)\n    } else {\n        fmt.Println(\"err doesn't match argError\")\n    }\n}\n</code></pre> <ol> <li>A custom error type usualy has the suffix \"Error\".</li> <li>Adding this <code>Error</code> method makes <code>argError</code> implement the error interface.</li> <li>Return our custom error.</li> <li><code>errors.As</code> is a more advanced version of <code>errors.Is</code>. It checks that a given error or any error in its chain matches a specific error type and converts to a value of that     type, returning <code>true</code>. If there\u2019s no match, it returns <code>false</code>.</li> </ol> Go allows you to define custom error types. <p>Go allows you to define custom error types by implementing the <code>Error()</code> method on a custom type. By defining a custom error type, you can create more descriptive and  informative error messages that provide additional context about the error condition. Custom error types are useful for handling specific error cases and for providing  detailed information about the cause of an error.</p> Go provides advanced error handling functions like <code>errors.As</code>. <p>Go provides advanced error handling functions like <code>errors.As</code> that allow you to check if an error matches a specific error type and convert it to a value of that type. These  functions are useful for working with custom error types and for handling errors in a more flexible and robust way. By using these functions, you can write code that is more  resilient to errors and that provides better error handling and reporting.</p>"},{"location":"#goroutines","title":"Goroutines","text":"<p>A goroutine is a lightweight thread of execution.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc f(from string) {\n    for i := 0; i &lt; 3; i++ {\n        fmt.Println(from, \":\", i)\n    }\n}\n\nfunc main() {\n\n    f(\"direct\") // (1)!\n\n    go f(\"goroutine\") // (2)!\n\n    go func(msg string) { // (3)!\n        fmt.Println(msg)\n    }(\"going\")\n\n    time.Sleep(time.Second) // (4)!\n    fmt.Println(\"done\")\n}\n</code></pre> <ol> <li>Suppose we have a function call <code>f(s)</code>. Here\u2019s how we\u2019d call that in the usual way, running it synchronously.</li> <li>To invoke this function in a goroutine, use <code>go f(s)</code>. This new goroutine will execute concurrently with the calling one.</li> <li>You can also start a goroutine for an anonymous function call.</li> <li>Our two function calls are running asynchronously in separate goroutines now. Wait for them to finish (for a more robust approach, use a <code>WaitGroup</code>).</li> </ol> <p>When we run this program, we see the output of the blocking call first, then the output of the two goroutines.  The goroutines\u2019 output may be interleaved, because goroutines are being run concurrently by the Go runtime.</p> <pre><code>$ go run goroutines.go\ndirect : 0\ndirect : 1\ndirect : 2\ngoroutine : 0\ngoing\ngoroutine : 1\ngoroutine : 2\ndone\n</code></pre> Go goroutines are lightweight threads of execution. <p>Go goroutines are lightweight threads of execution that allow you to run multiple tasks concurrently within a single program. Goroutines are managed by the Go runtime and are  scheduled to run on available CPU cores, enabling you to write concurrent programs that can perform multiple tasks simultaneously. Goroutines are a powerful feature of Go that  make it easy to write efficient and scalable programs.</p> <p>Go uses the <code>go</code> keyword to start a goroutine.</p>"},{"location":"#channels","title":"Channels","text":"<p>Channels are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive those values into another goroutine.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    messages := make(chan string) // (1)!\n\n    go func() { messages &lt;- \"ping\" }() // (2)!\n\n    msg := &lt;-messages // (3)!\n    fmt.Println(msg)\n}\n</code></pre> <ol> <li>Create a new channel with <code>make(chan val-type)</code>. Channels are typed by the values they convey.</li> <li>Send a value into a channel using the <code>channel &lt;-</code> syntax. Here we send \"ping\" to the messages channel we made above, from a new goroutine.</li> <li>The <code>&lt;-channel</code> syntax receives a value from the channel. Here we\u2019ll receive the \"ping\" message we sent above and print it out.</li> </ol> <p>When we run the program the \"ping\" message is successfully passed from one goroutine to another via our channel.</p> Go channels are used to communicate between goroutines. <p>Go channels are used to communicate between concurrent goroutines in a Go program. Channels provide a way to send and receive values between goroutines, enabling you to  coordinate the execution of multiple goroutines and share data between them. Channels are a powerful feature of Go that make it easy to write concurrent programs that can  communicate and synchronize effectively.</p> By default, sends and receives block until both the sender and receiver are ready. <p>Go channels are synchronous by default, meaning that sends and receives block until both the sender and receiver are ready. This property allows you to coordinate the  execution of multiple goroutines and ensure that data is sent and received in the correct order. Channels provide a simple and efficient way to communicate between  goroutines in a Go program.</p>"},{"location":"#channel-buffering","title":"Channel Buffering","text":"<p>By default, channels are unbuffered, meaning that they will only accept sends (<code>chan &lt;-</code>) if there is a corresponding receive (<code>&lt;- chan</code>) ready to receive the sent value.  Buffered channels accept a limited number of values without a corresponding receiver for those values. This concept is similar to mailboxes in RTOS.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    messages := make(chan string, 2) // (1)!\n\n    messages &lt;- \"buffered\" // (2)!\n    messages &lt;- \"channel\"\n\n    fmt.Println(&lt;-messages) // (3)!\n    fmt.Println(&lt;-messages)\n}\n</code></pre> <ol> <li>Here we make a channel of strings buffering up to 2 values.</li> <li>Because this channel is buffered, we can send these values into the channel without a corresponding concurrent receive.</li> <li>Later we can receive these two values as usual.</li> </ol> Go channels can be buffered to accept a limited number of values. <p>Go channels can be buffered to accept a limited number of values without a corresponding receiver. Buffered channels provide a way to store values temporarily until they  are received by a goroutine, enabling you to send and receive values asynchronously. Buffered channels are useful for coordinating the execution of multiple goroutines and  for managing the flow of data between goroutines.</p>"},{"location":"#channel-synchronization","title":"Channel Synchronization","text":"<p>We can use channels to synchronize execution across goroutines. Here\u2019s an example of using a blocking receive to wait for a goroutine to finish. When waiting for multiple goroutines to finish, you may prefer to use a WaitGroup.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(done chan bool) { // (1)!\n    fmt.Print(\"working...\")\n    time.Sleep(time.Second)\n    fmt.Println(\"done\")\n\n    done &lt;- true // (2)!\n}\n\nfunc main() {\n\n    done := make(chan bool, 1)\n    go worker(done) // (3)!\n\n    &lt;-done // (4)!\n}\n</code></pre> <ol> <li>This is the function we\u2019ll run in a goroutine. The <code>done</code> channel will be used to notify another goroutine that this function\u2019s work is done.</li> <li>Send a value to notify that we\u2019re done.</li> <li>Start a worker goroutine, giving it the channel to notify on.</li> <li>Block until we receive a notification from the worker on the channel.</li> </ol> <p>If you removed the <code>&lt;- done</code> line from this program, the program would exit before the worker even started.</p> Go channels can be used to synchronize goroutines. <p>Go channels can be used to synchronize the execution of goroutines in a Go program. By using channels to send and receive values between goroutines, you can coordinate the  execution of multiple goroutines and ensure that they run in the correct order. Channels provide a simple and efficient way to synchronize the execution of goroutines and to  manage the flow of data between them.</p>"},{"location":"#channel-directions","title":"Channel Directions","text":"<p>When using channels as function parameters, you can specify if a channel is meant to only send or receive values. This specificity increases the type-safety of the program.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc ping(pings chan&lt;- string, msg string) { // (1)!\n    pings &lt;- msg\n}\n\nfunc pong(pings &lt;-chan string, pongs chan&lt;- string) { // (2)!\n    msg := &lt;-pings\n    pongs &lt;- msg\n}\n\nfunc main() {\n    pings := make(chan string, 1)\n    pongs := make(chan string, 1)\n    ping(pings, \"passed message\")\n    pong(pings, pongs)\n    fmt.Println(&lt;-pongs)\n}\n</code></pre> <ol> <li>This <code>ping</code> function only accepts a channel for sending values. It would be a compile-time error to try to receive on this channel.</li> <li>The <code>pong</code> function accepts one channel for receives (pings) and a second for sends (pongs).</li> </ol> Go channels can have send-only or receive-only directions. <p>Go channels can have send-only or receive-only directions, allowing you to specify whether a channel is meant to only send or receive values. By using channel  directions, you can make your code more type-safe and prevent errors by ensuring that channels are used correctly in your program. Channel directions provide a way to  enforce the correct usage of channels and to improve the reliability and robustness of your code.</p>"},{"location":"#select","title":"Select","text":"<p>Go\u2019s select lets you wait on multiple channel operations. Combining goroutines and channels with select is a powerful feature of Go.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    c1 := make(chan string) // (1)!\n    c2 := make(chan string)\n\n    go func() { // (2)!\n        time.Sleep(1 * time.Second)\n        c1 &lt;- \"one\"\n    }()\n    go func() {\n        time.Sleep(2 * time.Second)\n        c2 &lt;- \"two\"\n    }()\n\n    for i := 0; i &lt; 2; i++ {\n        select { // (3)!\n        case msg1 := &lt;-c1:\n            fmt.Println(\"received\", msg1)\n        case msg2 := &lt;-c2:\n            fmt.Println(\"received\", msg2)\n        }\n    }\n}\n</code></pre> <ol> <li>For our example we\u2019ll select across two channels.</li> <li>Each channel will receive a value after some amount of time, to simulate e.g. blocking RPC operations executing in concurrent goroutines.</li> <li>We\u2019ll use <code>select</code> to await both of these values simultaneously, printing each one as it arrives.</li> </ol> <p>We receive the values \"one\" and then \"two\" as expected.</p> <p>Note that the total execution time is only ~2 seconds since both the 1 and 2 second Sleeps execute concurrently.</p> Go select allows you to wait on multiple channel operations. <p>Go select allows you to wait on multiple channel operations in a Go program. By using select, you can wait for multiple channels to send or receive values and respond to the  first channel that is ready. Select provides a way to coordinate the execution of multiple goroutines and to synchronize the flow of data between them, enabling you to write  efficient and scalable concurrent programs.</p>"},{"location":"#timeouts","title":"Timeouts","text":"<p>Timeouts are important for programs that connect to external resources or that otherwise need to bound execution time. Implementing timeouts in Go is easy and elegant thanks to channels and select.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    c1 := make(chan string, 1) // (1)!\n    go func() {\n        time.Sleep(2 * time.Second)\n        c1 &lt;- \"result 1\"\n    }()\n\n    select { // (2)!\n    case res := &lt;-c1:\n        fmt.Println(res)\n    case &lt;-time.After(1 * time.Second):\n        fmt.Println(\"timeout 1\")\n    }\n\n    c2 := make(chan string, 1) // (3)!\n    go func() {\n        time.Sleep(2 * time.Second)\n        c2 &lt;- \"result 2\"\n    }()\n    select {\n    case res := &lt;-c2:\n        fmt.Println(res)\n    case &lt;-time.After(3 * time.Second):\n        fmt.Println(\"timeout 2\")\n    }\n}\n</code></pre> <ol> <li>For our example, suppose we\u2019re executing an external call that returns its result on a channel <code>c1</code> after 2s. Note that the channel is buffered, so the send in the goroutine     is nonblocking. This is a common pattern to prevent goroutine leaks in case the channel is never read.</li> <li>Here\u2019s the <code>select</code> implementing a timeout. <code>res := &lt;-c1</code> awaits the result and <code>&lt;-time.After</code> awaits a value to be sent after the timeout of 1s. Since <code>select</code> proceeds     with the first receive that\u2019s ready, we\u2019ll take the timeout case if the operation takes more than the allowed 1s.</li> <li>If we allow a longer timeout of 3s, then the receive from <code>c2</code> will succeed and we\u2019ll print the result.</li> </ol> <p>Running this program shows the first operation timing out and the second succeeding.</p> Go select can be used to implement timeouts in Go programs. <p>Go select can be used to implement timeouts in Go programs, allowing you to set a maximum time limit for operations that may take longer than expected. By using select with  time.After, you can wait for a specified duration and respond to the first channel that is ready, enabling you to handle timeouts and prevent long-running operations from  blocking your program. Timeouts are an important feature of Go programs that help ensure that operations complete within a reasonable time frame.</p>"},{"location":"#non-blocking-channel-operations","title":"Non-Blocking Channel Operations","text":"<p>Basic sends and receives on channels are blocking. However, we can use <code>select</code> with a default clause to implement non-blocking sends, receives, and even non-blocking multi-way  <code>selects</code>.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    messages := make(chan string)\n    signals := make(chan bool)\n\n    select { // (1)!\n    case msg := &lt;-messages:\n        fmt.Println(\"received message\", msg)\n    default:\n        fmt.Println(\"no message received\")\n    }\n\n    msg := \"hi\" // (2)!\n    select {\n    case messages &lt;- msg:\n        fmt.Println(\"sent message\", msg)\n    default:\n        fmt.Println(\"no message sent\")\n    }\n\n    select { // (3)!\n    case msg := &lt;-messages:\n        fmt.Println(\"received message\", msg)\n    case sig := &lt;-signals:\n        fmt.Println(\"received signal\", sig)\n    default:\n        fmt.Println(\"no activity\")\n    }\n}\n</code></pre> <ol> <li>Here\u2019s a non-blocking receive. If a value is available on messages then select will take the <code>&lt;-messages</code> case with that value. If not it will immediately take the <code>default</code>     case.</li> <li>A non-blocking send works similarly. Here <code>msg</code> cannot be sent to the messages channel, because the channel has no buffer and there is no receiver. Therefore the <code>default</code> case     is selected.</li> <li>We can use multiple <code>cases</code> above the default clause to implement a multi-way non-blocking select. Here we attempt non-blocking receives on both <code>messages</code> and <code>signals</code>.</li> </ol> Go select with default clause can be used to implement non-blocking channel operations. <p>Go select with a default clause can be used to implement non-blocking channel operations in a Go program. By using select with a default case, you can perform non-blocking  sends and receives on channels, enabling you to handle channel operations that may not be ready immediately. Non-blocking channel operations are useful for writing efficient  and responsive code that can handle multiple tasks concurrently.</p>"},{"location":"#closing-channels","title":"Closing Channels","text":"<p>Closing a channel indicates that no more values will be sent on it. This can be useful to communicate completion to the channel\u2019s receivers.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() { // (1)!\n    jobs := make(chan int, 5)\n    done := make(chan bool)\n\n    go func() { // (2)!\n        for {\n            j, more := &lt;-jobs\n            if more {\n                fmt.Println(\"received job\", j)\n            } else {\n                fmt.Println(\"received all jobs\")\n                done &lt;- true\n                return\n            }\n        }\n    }()\n\n    for j := 1; j &lt;= 3; j++ { // (3)!\n        jobs &lt;- j\n        fmt.Println(\"sent job\", j)\n    }\n    close(jobs)\n    fmt.Println(\"sent all jobs\")\n\n    &lt;-done // (4)!\n\n    _, ok := &lt;-jobs // (5)!\n    fmt.Println(\"received more jobs:\", ok)\n}\n</code></pre> <ol> <li>In this example we\u2019ll use a jobs channel to communicate work to be done from the<code>main()</code> goroutine to a worker goroutine. When we have no more jobs for the worker we\u2019ll <code>close</code>     the jobs channel.</li> <li>Here\u2019s the worker goroutine. It repeatedly receives from jobs with <code>j, more := &lt;-jobs</code>. In this special 2-value form of receive, the more value will be <code>false</code> if jobs has been     closed and all values in the channel have already been received. We use this to notify on done when we\u2019ve worked all our jobs.</li> <li>This sends 3 jobs to the worker over the jobs channel, then closes it.</li> <li>We await the worker using the synchronization approach we saw earlier.</li> <li>Reading from a closed channel succeeds immediately, returning the zero value of the underlying type. The optional second return value is <code>true</code> if the value received was     delivered by a successful send operation to the channel, or <code>false</code> if it was a zero value generated because the channel is closed and empty.</li> </ol> Go channels can be closed to indicate completion. <p>Go channels can be closed to indicate that no more values will be sent on the channel, allowing you to communicate completion to the channel\u2019s receivers. By closing a channel,  you can signal that all values have been sent and that the channel is no longer in use. Closing channels is a useful feature of Go that enables you to coordinate the execution  of multiple goroutines and to manage the flow of data between them.</p>"},{"location":"#range-over-channels","title":"Range over Channels","text":"<p>In a previous example we saw how for and range provide iteration over basic data structures. We can also use this syntax to iterate over values received from a channel.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    queue := make(chan string, 2) // (1)!\n    queue &lt;- \"one\"\n    queue &lt;- \"two\"\n    close(queue)\n\n    for elem := range queue { // (2)!\n        fmt.Println(elem)\n    }\n}\n</code></pre> <ol> <li>We\u2019ll iterate over 2 values in the <code>queue</code> channel.</li> <li>This <code>range</code> iterates over each element as it\u2019s received from <code>queue</code>. Because we closed the channel above, the iteration terminates after receiving the 2 elements.</li> </ol> <p>This example also showed that it\u2019s possible to close a non-empty channel but still have the remaining values be received.</p> Go range can be used to iterate over values received from a channel. <p>Go range can be used to iterate over values received from a channel in a Go program. By using range with a channel, you can iterate over the values sent on the channel and  process them in a loop. Range provides a convenient way to receive values from a channel and to handle them in a loop, enabling you to write efficient and concise code that  processes data sent on a channel.</p>"},{"location":"#timers","title":"Timers","text":"<p>We often want to execute Go code at some point in the future, or repeatedly at some interval. Go\u2019s built-in timer and ticker features make both of these tasks easy. We\u2019ll look  first at timers and then at tickers.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    timer1 := time.NewTimer(2 * time.Second) // (1)!\n\n    &lt;-timer1.C // (2)!\n    fmt.Println(\"Timer 1 fired\")\n\n    timer2 := time.NewTimer(time.Second) // (3)!\n    go func() {\n        &lt;-timer2.C\n        fmt.Println(\"Timer 2 fired\")\n    }()\n    stop2 := timer2.Stop()\n    if stop2 {\n        fmt.Println(\"Timer 2 stopped\")\n    }\n\n    time.Sleep(2 * time.Second) // (4)!\n}\n</code></pre> <ol> <li>Timers represent a single event in the future. You tell the timer how long you want to wait, and it provides a channel that will be notified at that time. This timer will wait     2 seconds.</li> <li>The <code>&lt;-timer1.C</code> blocks on the timer\u2019s channel <code>C</code> until it sends a value indicating that the timer fired.</li> <li>If you just wanted to wait, you could have used <code>time.Sleep</code>. One reason a timer may be useful is that you can cancel the timer before it fires. Here\u2019s an example of that.</li> <li>Give the <code>timer2</code> enough time to fire, if it ever was going to, to show it is in fact stopped.</li> </ol> <p>The first timer will fire ~2s after we start the program, but the second should be stopped before it has a chance to fire.</p> Go timers can be used to execute code at a specific time in the future. <p>Go timers can be used to execute code at a specific time in the future in a Go program. By creating a timer with a duration and waiting for the timer to fire, you can schedule  code to run after a certain amount of time has elapsed. Timers provide a way to delay the execution of code and to perform tasks at a specific time, enabling you to write  programs that can perform time-based operations efficiently.</p>"},{"location":"#tickers","title":"Tickers","text":"<p>Timers are for when you want to do something once in the future - tickers are for when you want to do something repeatedly at regular intervals. Here\u2019s an example of a  ticker that ticks periodically until we stop it.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    ticker := time.NewTicker(500 * time.Millisecond) // (1)!\n    done := make(chan bool)\n\n    go func() {\n        for {\n            select {\n            case &lt;-done:\n                return\n            case t := &lt;-ticker.C:\n                fmt.Println(\"Tick at\", t)\n            }\n        }\n    }()\n\n    time.Sleep(1600 * time.Millisecond) // (2)!\n    ticker.Stop()\n    done &lt;- true\n    fmt.Println(\"Ticker stopped\")\n}\n</code></pre> <ol> <li>Tickers use a similar mechanism to timers: a channel that is sent values. Here we\u2019ll use the <code>select</code> builtin on the channel to await the values as they arrive every 500ms.</li> <li>Tickers can be stopped like timers. Once a ticker is stopped it won\u2019t receive any more values on its channel. We\u2019ll stop ours after 1600ms.</li> </ol> <p>When we run this program the ticker should tick 3 times before we stop it.</p> Go tickers can be used to execute code repeatedly at regular intervals. <p>Go tickers can be used to execute code repeatedly at regular intervals in a Go program. By creating a ticker with a duration and waiting for the ticker to send values on its  channel, you can perform tasks at regular intervals and schedule code to run periodically. Tickers provide a way to perform time-based operations that need to be repeated  multiple times, enabling you to write programs that can execute code at regular intervals efficiently.</p> Go tickers are executed in a separate goroutine. <p>Go tickers are executed in a separate goroutine, allowing you to run code periodically without blocking the main goroutine. By using a ticker to schedule code to run at  regular intervals, you can perform tasks in the background while the main goroutine continues to execute other operations. You should protect shared resources accessed by the ticker goroutine to prevent race conditions and ensure that the program runs correctly.</p>"},{"location":"#worker-pools","title":"Worker Pools","text":"<p>In this example we\u2019ll look at how to implement a worker pool using goroutines and channels.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(id int, jobs &lt;-chan int, results chan&lt;- int) { // (1)!\n    for j := range jobs {\n        fmt.Println(\"worker\", id, \"started  job\", j)\n        time.Sleep(time.Second)\n        fmt.Println(\"worker\", id, \"finished job\", j)\n        results &lt;- j * 2\n    }\n}\n\nfunc main() {\n\n    const numJobs = 5 // (2)!\n    jobs := make(chan int, numJobs)\n    results := make(chan int, numJobs)\n\n    for w := 1; w &lt;= 3; w++ { // (3)!\n        go worker(w, jobs, results)\n    }\n\n    for j := 1; j &lt;= numJobs; j++ { // (4)!\n        jobs &lt;- j\n    }\n    close(jobs)\n\n    for a := 1; a &lt;= numJobs; a++ { // (5)!\n        &lt;-results\n    }\n}\n</code></pre> <ol> <li>Here\u2019s the worker, of which we\u2019ll run several concurrent instances. These workers will receive work on the jobs channel and send the corresponding results on results. We\u2019ll     sleep a second per job to simulate an expensive task.</li> <li>In order to use our pool of workers we need to send them work and collect their results. We make 2 channels for this.</li> <li>This starts up 3 workers, initially blocked because there are no jobs yet.</li> <li>Here we send 5 jobs and then close that channel to indicate that\u2019s all the work we have.</li> <li>Finally we collect all the results of the work. This also ensures that the worker goroutines have finished. An alternative way to wait for multiple goroutines is to use a     WaitGroup.</li> </ol> <p>Our running program shows the 5 jobs being executed by various workers. The program only takes about 2 seconds despite doing about 5 seconds of total work because there are 3  workers operating concurrently.</p> Go worker pools can be used to execute tasks concurrently. <p>Go worker pools can be used to execute tasks concurrently in a Go program. By creating a pool of worker goroutines that can process tasks in parallel, you can perform multiple  tasks simultaneously and improve the efficiency of your program. Worker pools provide a way to distribute work across multiple goroutines and to execute tasks concurrently,  enabling you to write programs that can perform complex operations efficiently.</p> Go channels can be used to coordinate worker pools."},{"location":"#waitgroups","title":"WaitGroups","text":"<p>To wait for multiple goroutines to finish, we can use a wait group.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc worker(id int) { // (1)!\n    fmt.Printf(\"Worker %d starting\\n\", id)\n\n    time.Sleep(time.Second) // (2)!\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n\n    var wg sync.WaitGroup // (3)!\n\n    for i := 1; i &lt;= 5; i++ { // (4)!\n        wg.Add(1)\n\n        go func() { // (5)!\n            defer wg.Done()\n            worker(i)\n        }()\n    }\n\n    wg.Wait() // (6)!\n\n}\n</code></pre> <ol> <li>This is the function we\u2019ll run in every goroutine.</li> <li>Sleep to simulate an expensive task.</li> <li>This WaitGroup is used to wait for all the goroutines launched here to finish. Note: if a WaitGroup is explicitly passed into functions, it should be done by pointer.</li> <li>Launch several goroutines and increment the WaitGroup counter for each.</li> <li>Wrap the worker call in a closure that makes sure to tell the WaitGroup that this worker is done. This way the worker itself does not have to be aware of the concurrency     primitives involved in its execution.</li> <li>Block until the WaitGroup counter goes back to 0; all the workers notified they\u2019re done.</li> </ol> <p>The order of workers starting up and finishing is likely to be different for each invocation.</p> Go WaitGroups can be used to wait for multiple goroutines to finish. <p>Go WaitGroups can be used to wait for multiple goroutines to finish in a Go program. By using a WaitGroup to track the completion of multiple goroutines, you can ensure that  all the goroutines have finished executing before proceeding with the rest of the program. WaitGroups provide a way to synchronize the execution of multiple goroutines and to  coordinate the flow of control between them, enabling you to write efficient and reliable concurrent programs.</p> This approach has no straightforward way to propagate errors from workers. <p>For more advanced use cases, consider using the <code>errgroup</code> package.\"</p>"},{"location":"#rate-limiting","title":"Rate Limiting","text":"<p>Rate limiting is an important mechanism for controlling resource utilization and maintaining quality of service. Go elegantly supports rate limiting with goroutines,  channels, and tickers.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    requests := make(chan int, 5) // (1)!\n    for i := 1; i &lt;= 5; i++ {\n        requests &lt;- i\n    }\n    close(requests)\n\n    limiter := time.Tick(200 * time.Millisecond) // (2)!\n\n    for req := range requests { // (3)!\n        &lt;-limiter\n        fmt.Println(\"request\", req, time.Now())\n    }\n\n    burstyLimiter := make(chan time.Time, 3) // (4)!\n\n    for i := 0; i &lt; 3; i++ { // (5)!\n        burstyLimiter &lt;- time.Now()\n    }\n\n    go func() { // (6)!\n        for t := range time.Tick(200 * time.Millisecond) {\n            burstyLimiter &lt;- t\n        }\n    }()\n\n    burstyRequests := make(chan int, 5)\n    for i := 1; i &lt;= 5; i++ { // (7)!\n        burstyRequests &lt;- i\n    }\n    close(burstyRequests)\n    for req := range burstyRequests {\n        &lt;-burstyLimiter\n        fmt.Println(\"request\", req, time.Now())\n    }\n}\n</code></pre> <ol> <li>First we\u2019ll look at basic rate limiting. Suppose we want to limit our handling of incoming requests. We\u2019ll serve these requests off a channel of the same name.</li> <li>This <code>limiter</code> channel will receive a value every 200 milliseconds. This is the regulator in our rate limiting scheme.</li> <li>By blocking on a <code>receive</code> from the limiter channel before serving each request, we limit ourselves to 1 request every 200 milliseconds.</li> <li>We may want to allow short bursts of requests in our rate limiting scheme while preserving the overall rate limit. We can accomplish this by buffering our limiter channel.    This <code>burstyLimiter</code> channel will allow bursts of up to 3 events.</li> <li>Fill up the channel to represent allowed bursting.</li> <li>Every 200 milliseconds we\u2019ll try to add a new value to <code>burstyLimiter</code>, up to its limit of 3.</li> <li>Now simulate 5 more incoming requests. The first 3 of these will benefit from the burst capability of <code>burstyLimiter</code>.</li> </ol> <p>Running our program we see the first batch of requests handled once every ~200 milliseconds as desired. For the second batch of requests we serve the first 3 immediately because  of the burstable rate limiting, then serve the remaining 2 with ~200ms delays each.</p> Go rate limiting can be used to control resource utilization and maintain quality of service. <p>Go rate limiting can be used to control resource utilization and maintain quality of service in a Go program. By using rate limiting with goroutines, channels, and tickers, you  can regulate the flow of requests and limit the rate at which operations are performed, enabling you to manage resource consumption and ensure that your program operates  efficiently. Rate limiting is an important mechanism for controlling the rate of requests and preventing resource exhaustion in a Go program.</p>"},{"location":"#atomic-counters","title":"Atomic Counters","text":"<p>The primary mechanism for managing state in Go is communication over channels. We saw this for example with worker pools. There are a few other options for managing state though.  Here we\u2019ll look at using the <code>sync/atomic</code> package for atomic counters accessed by multiple goroutines.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n\n    var ops atomic.Uint64 // (1)!\n\n    var wg sync.WaitGroup // (2)!\n\n    for i := 0; i &lt; 50; i++ { // (3)!\n        wg.Add(1)\n\n        go func() {\n            for c := 0; c &lt; 1000; c++ {\n\n                ops.Add(1)  // (4)!\n            }\n\n            wg.Done()\n        }()\n    }\n\n    wg.Wait() // (5)!\n\n    fmt.Println(\"ops:\", ops.Load()) // (6)!\n}\n</code></pre> <ol> <li>We\u2019ll use an atomic integer type to represent our (always-positive) counter.</li> <li>A WaitGroup will help us wait for all goroutines to finish their work.</li> <li>We\u2019ll start 50 goroutines that each increment the counter exactly 1000 times.</li> <li>To atomically increment the counter we use <code>Add</code>.</li> <li>Wait until all the goroutines are done.</li> <li>Here no goroutines are writing to <code>ops</code>, but using Load it\u2019s safe to atomically read a value even while other goroutines are (atomically) updating it.</li> </ol> <p>We expect to get exactly 50,000 operations. Had we used a non-atomic integer and incremented it with ops++, we\u2019d likely get a different number, changing between runs, because the  goroutines would interfere with each other. Moreover, we\u2019d get data race failures when running with the -race flag.</p> Go atomic counters can be used to manage shared state in a concurrent program. <p>Go atomic counters can be used to manage shared state in a concurrent program by providing a way to perform atomic operations on shared variables. By using atomic counters to  manage shared state, you can ensure that the state is updated safely and reliably by multiple goroutines.</p> Go atomic counters are used to perform atomic operations on shared variables."},{"location":"#mutexes","title":"Mutexes","text":"<p>In the previous example we saw how to manage simple counter state using atomic operations. For more complex state we can use a mutex to safely access data across multiple  goroutines.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype Container struct { // (1)!\n    mu       sync.Mutex\n    counters map[string]int\n}\n\nfunc (c *Container) inc(name string) { // (2)!\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.counters[name]++\n}\n\nfunc main() { // (3)!\n    c := Container{\n        counters: map[string]int{\"a\": 0, \"b\": 0},\n    }\n\n    var wg sync.WaitGroup\n\n    doIncrement := func(name string, n int) { // (4)!\n        for i := 0; i &lt; n; i++ {\n            c.inc(name)\n        }\n        wg.Done()\n    }\n\n    wg.Add(3) // (5)!\n    go doIncrement(\"a\", 10000)\n    go doIncrement(\"a\", 10000)\n    go doIncrement(\"b\", 10000)\n\n    wg.Wait() // (6)!\n    fmt.Println(c.counters)\n}\n</code></pre> <ol> <li>Container holds a map of counters; since we want to update it concurrently from multiple goroutines, we add a Mutex to synchronize access. Note that mutexes must not be copied,     so if this <code>struct</code> is passed around, it should be done by pointer.</li> <li>Lock the mutex before accessing counters; unlock it at the end of the function using a <code>defer</code> statement.</li> <li>Note that the zero value of a mutex is usable as-is, so no initialization is required here.</li> <li>This function increments a named counter in a loop.</li> <li>Run several goroutines concurrently; note that they all access the same Container, and two of them access the same counter.</li> <li>Wait for the goroutines to finish</li> </ol> <p>Running the program shows that the counters updated as expected.</p> Go mutexes can be used to synchronize access to shared data in a concurrent program. <p>Go mutexes can be used to synchronize access to shared data in a concurrent program by providing a way to protect shared resources from concurrent access. By using mutexes to  lock and unlock access to shared data, you can ensure that only one goroutine can access the data at a time.</p>"},{"location":"#sorting","title":"Sorting","text":"<p>Go\u2019s slices package implements sorting for builtins and user-defined types. We\u2019ll look at sorting for builtins first.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"slices\"\n)\n\nfunc main() {\n\n    strs := []string{\"c\", \"a\", \"b\"}\n    slices.Sort(strs) // (1)!\n    fmt.Println(\"Strings:\", strs)\n\n    ints := []int{7, 2, 4}\n    slices.Sort(ints) // (2)!\n    fmt.Println(\"Ints:   \", ints)\n\n    s := slices.IsSorted(ints) // (3)!\n    fmt.Println(\"Sorted: \", s)\n}\n</code></pre> <ol> <li>Sorting functions are generic, and work for any ordered built-in type. For a list of ordered types, see <code>cmp.Ordered</code>.</li> <li>An example of sorting <code>ints</code>.</li> <li>We can also use the <code>slices</code> package to check if a slice is already in sorted order.</li> </ol> Go slices package provides functions for sorting slices. <p>Go slices package provides functions for sorting slices of built-in types in a Go program. By using the Sort function from the slices package, you can sort slices of strings,  integers, and other built-in types, enabling you to organize and order data efficiently. The slices package provides a simple and efficient way to sort slices of data in a Go  program.</p> Go slices package provides functions for checking if a slice is sorted."},{"location":"#sorting-by-functions","title":"Sorting by Functions","text":"<p>Sometimes we\u2019ll want to sort a collection by something other than its natural order. For example, suppose we wanted to sort strings by their length instead of alphabetically.  Here\u2019s an example of custom sorts in Go.</p> <pre><code>package main\n\nimport (\n    \"cmp\"\n    \"fmt\"\n    \"slices\"\n)\n\nfunc main() {\n    fruits := []string{\"peach\", \"banana\", \"kiwi\"}\n\n    lenCmp := func(a, b string) int { // (1)!\n        return cmp.Compare(len(a), len(b))\n    }\n\n    slices.SortFunc(fruits, lenCmp) // (2)!\n    fmt.Println(fruits)\n\n    type Person struct { // (3)!\n        name string\n        age  int\n    }\n\n    people := []Person{\n        Person{name: \"Jax\", age: 37},\n        Person{name: \"TJ\", age: 25},\n        Person{name: \"Alex\", age: 72},\n    }\n\n    slices.SortFunc(people, // (4)!\n        func(a, b Person) int {\n            return cmp.Compare(a.age, b.age)\n        })\n    fmt.Println(people)\n}\n</code></pre> <ol> <li>We implement a comparison function for <code>string</code> lengths. <code>cmp.Compare</code> is helpful for this.</li> <li>Now we can call <code>slices.SortFunc</code> with this custom comparison function to sort fruits by name length.</li> <li>We can use the same technique to sort a slice of values that aren\u2019t built-in types.</li> <li>Sort <code>people</code> by age using <code>slices.SortFunc</code>.</li> </ol> <p>If the <code>Person</code> struct is large, you may want the slice to contain <code>*Person</code> instead and adjust the sorting function accordingly. If in doubt, prefer the pointer variant!</p> Go slices package provides functions for sorting slices by custom comparison functions. <p>Go slices package provides functions for sorting slices by custom comparison functions in a Go program. By using the SortFunc function from the slices package, you can sort  slices of data by custom comparison functions, enabling you to order data based on specific criteria and requirements. The slices package provides a flexible and efficient way  to sort slices of data by custom comparison functions in a Go program.</p>"},{"location":"#regular-expressions","title":"Regular Expressions","text":"<p>Go offers built-in support for regular expressions. Here are some examples of common regexp-related tasks in Go.</p> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n\n    match, _ := regexp.MatchString(\"p([a-z]+)ch\", \"peach\")\n    fmt.Println(match)\n\n    r, _ := regexp.Compile(\"p([a-z]+)ch\")\n\n    fmt.Println(r.MatchString(\"peach\"))\n\n    fmt.Println(r.FindString(\"peach punch\"))\n\n    fmt.Println(\"idx:\", r.FindStringIndex(\"peach punch\"))\n\n    fmt.Println(r.FindStringSubmatch(\"peach punch\"))\n\n    fmt.Println(r.FindStringSubmatchIndex(\"peach punch\"))\n\n    fmt.Println(r.FindAllString(\"peach punch pinch\", -1))\n\n    fmt.Println(\"all:\", r.FindAllStringSubmatchIndex(\n        \"peach punch pinch\", -1))\n\n    fmt.Println(r.FindAllString(\"peach punch pinch\", 2))\n\n    fmt.Println(r.Match([]byte(\"peach\")))\n\n    r = regexp.MustCompile(\"p([a-z]+)ch\")\n    fmt.Println(\"regexp:\", r)\n\n    fmt.Println(r.ReplaceAllString(\"a peach\", \"&lt;fruit&gt;\"))\n\n    in := []byte(\"a peach\")\n    out := r.ReplaceAllFunc(in, bytes.ToUpper)\n    fmt.Println(string(out))\n}\n</code></pre>"}]}